---
title: "Ohio 2012 Presidential Campaign Contributions by Christopher Winkelman"
output:
  html_document:
    fig_width: 10
    fig_height: 5
---

========================================================

```{r packages, echo=FALSE, message=FALSE, warning=FALSE}
# Load all of the packages

library(readr)
#library(devtools)
#install_github('arilamstein/choroplethrZip@v1.3.0')
library(choroplethrZip)


library(ggplot2)
library(dplyr)
library(zipcode)

library(rvest)
library(stringr)
library(gender)
library(lubridate)
library(GGally)
library(memisc)
library(gridExtra)
library(RColorBrewer)
```

# Introduction
This project is an exploratory data analysis of campaign contributions for the 2012 presidential election in the state of Ohio.  I chose to look at Ohio because it has a history of being a critical swing state for presidential elections and, according to wikipedia, has the longest streak of matching the overall election outcome (since 1960).  Of course it would be a mistake to assume that campaign contributions are a predictor or even loosely correlated with votes, but Ohio is one of the most frequently visited states on a presidential nominee's campaign trail and for this reason it piqued my interest.   I'll explore the nature of campaign contributions and see if there are any interesting relationships in the data.  Anything of significance could be used as a hypothesis in future inferential or predictive analysis.  If there were any useful information that could be extracted here, it might be useful to a campaign manager who could act upon it.

There are 3 data sets here:
- campaign contribution data
- geographic data (to generate maps)
- demographic data (to add extra features)

The geographic and demographic data come from a library and are already nicely formatted.  The features in the campaign contribution data, however, might need some explicit type declarations.  Let's take a look at the first few rows to inspect the encoding.

```{r inspect, echo=FALSE}
# let' keep factors for now and see whether or not we need to set this to false
df.look <- read_csv("campaign-contributions-ohio-2012.csv", n_max = 100)
```

While trying to read the file, it looks like we are getting some kind of parsing warning about the expected number of columns.  Let's open up the file and manually read the first few lines including the header to see if we can find the problem.

```{r double-check}
con <- file("campaign-contributions-ohio-2012.csv", "r")
lines <- readLines(con, 5)
close(con)
lines # hard to see but it looks like we have an extra empty column at the end.

# we could use count.fields here but it opens up the entire file so
# let's avoid this and use it on a smaller test file.
con <- file("campaign-contributions-ohio-2012.csv", "r")
lines <- readLines(con, 20)
close(con)

# using write.csv() here seems to cause problems with escape characters
# using a connection object works better
con <- file("test.csv")
writeLines(lines, con)
close(con)

count.fields("test.csv", sep=",")
```

It looks like each row in the dataset aside from the header has an extra empty entry.  If we look at the dataframe with just the first 100 lines, we can actually see that the `readr` library handled this discrepancy perfectly.  It alerted with a warning but the data was read in the way we want with no errors.  We don't have to do anything but it's good to know that we've identified the problem.  Let's get back to inspecting the features types.

```{r}
str(df.look)
```

There are a few features that we want as factors such as candidate name, city, state, employer, and occupation, but unfortunately `readr` can't guess factors from characters unless you explicitly state all of them one by one with different commands.  We could set the date but it isn't in ISO format, so we'll have to do this manually too.

```{r load-data, echo=FALSE, message=FALSE, warning=FALSE}

# Load the Data

# CAMPAIGN CONTRIBUTION DATA
df <- read_csv("campaign-contributions-ohio-2012.csv")

# GEOGRAPHIC ZIPCODE DATA
data(zip.map)

# DEMOGRAPHIC DATA
data(df_zip_demographics)
```


What's the structure of our raw data?
```{r}
str(df)
str(zip.map)
str(df_zip_demographics)
```
The zipcodes in the geographic and demographic data are characters but in the contribution data it's a number.  We'll have to make it a character for consistency.


Now that we have all of our raw data, let's get those features in the right format.
```{r}
df$cand_nm <- as.factor(df$cand_nm)
df$contbr_city <- as.factor(df$contbr_city)
df$contbr_st <- as.factor(df$contbr_st)
# zipcode data from the map is character so let's do the same
df$contbr_zip <- as.character(df$contbr_zip)
df$contbr_employer <- as.factor(df$contbr_employer)
df$contbr_occupation <- as.factor(df$contbr_occupation)
df$contb_receipt_dt <- as.Date(df$contb_receipt_dt, format = "%d-%b-%y")
```

There are quite a few features in the contribution data that don't really help our exploration like the ID number of the candidate or the file number of the contribution.  The only features of interest are 'candidate', 'name' (of the contributor), 'city', 'state', 'zipcode', 'employer', 'occupation', 'amount', and 'date'.  Let's trim the data set so that it's more manageable.

```{r}
df <- df[, 3:11] # use indices to keep features since they are all consecutive
# let's rename the features to make them more readable
names(df) <- c("candidate", "name", "city", "state", "zipcode",
                 "employer", "occupation", "amount", "date")
summary(df)
```


We have negative amounts that are refunds, so we'll have to exclude those observations.  Also, some zipcodes either have the full 9 numbers or are wrong so we'll have to clean these.
```{r echo=FALSE}

# REFUNDS AND ZERO CONTRIBUTIONS
#
bad <- df$amount <= 0
df <- df[!bad, ]



#
# ZIPCODE CLEANING
#

# keep first 5 digits since the zip.map data only has 5 and we need to match
df$zipcode <- substring(df$zipcode, 1, 5)
# if starts with '45' or '44' or '43' then ok
zip.legit <- as.character(seq(43000, 46000, by = 1))
# convert non-legit zipcodes to 'NA' character ubt
# keep data even if the zipcode isn't legit, it could still be relevant
df$zipcode <- ifelse(df$zipcode %in% zip.legit, df$zipcode, 'NA')


table(df$zipcode)
#zip.count <- df %>% group_by(zipcode) %>% summarise(count = n())
# some zipcodes with not enough data for aggregate stats df by zipcode
#df$zipcode <- as.factor(df$zipcode)
```


Let's engineer some features to make the data more rich.  Gender from name and party status from candidate.
```{r echo=FALSE}
#
# ADDING GENDER
#
# the gender function returns an alphabetically ordered dataframe...
df$name <- as.character(df$name)
df$first_name <- substring(str_extract(df$name, ',\\s[A-Z]+'), 3, )
# have to specify to dplyr to call select correctly here
gender_names_df <- gender(unique(df$first_name)) %>%
  dplyr::select(name, gender)
# merge dataframe with gender names
df <- merge(df, gender_names_df,
            by.x = 'first_name', by.y = 'name', all.x = TRUE)
# get rid of first name now that we don't need it
df$first_name <- NULL
# get rid of gender names
gender_names_df <- NULL
# make gender a factor
df$gender <- as.factor(df$gender)

sum(is.na(df$gender))
# 4677 obs with NA gender


#
# ADDING PARTY STATUS
#
candidates <- unique(df$candidate)
democrat <- "Obama, Barack"
green <- "Stein, Jill"
republican <- candidates[!(candidates %in% c(democrat, green))]
df$party <- ifelse(df$candidate %in% republican, "republican",
                   ifelse(df$candidate == democrat, "democrat", "green"))
df$candidate <- as.factor(df$candidate)
df$party <- as.factor(df$party)

```


let's add demographic data to the dataset... and geographic...
```{r echo=FALSE}

#
# ADDING DEMOGRAPHIC DATA
#
data(df_zip_demographics)
demographics.ohio <- df_zip_demographics %>%
  filter(region %in% zip.legit)
df <- merge(df, demographics.ohio,
            by.x = 'zipcode', by.y = 'region', all.x = TRUE)
# rename so we can see easier in the ggpairs plot
colnames(df)[12:19] <- c("population", "pcnt_wht", "pcnt_blk", "pcnt_asn",
                         "pcnt_hsp", "percap_incm", "med_rent", "med_age")



#
# ADDING MAP DATA
#
#data(zip.map)
mapdata.ohio <- zip.map %>% filter(region %in% zip.legit) %>% arrange(order)



#
# ADDING CITY COORDINATE DATA
#
webpage_ohio_cities <-
  read_html("http://www.geonames.org/US/OH/largest-cities-in-ohio.html")
city_names <- webpage_ohio_cities %>%
  xml_find_all("//tr/td/a[contains(@href, 'geonames')]/text()") %>%
  as.character()
city_pop <- webpage_ohio_cities %>%
  xml_find_all("//tr/td[contains(@class, 'rightalign')]/text()") %>%
  as.character() %>%
  sub(",", "", .) %>%
  as.numeric()
city_coord <- webpage_ohio_cities %>%
  xml_find_all('//tr/td/a[contains(@href, "maps")]/text()') %>%
  as.character()
city_lat <- as.numeric(str_extract(city_coord, '^[0-9.]+'))
city_long <- as.numeric(str_extract(city_coord, '[-0-9.]+$'))
mapdata.ohio.cities <- data.frame(city_names, city_long, city_lat, city_pop)

# double check object classes for each features
sapply(df, class)
```

# Univariate Plots Section
```{r echo=FALSE, message=FALSE, warning=FALSE, Univariate_Plots}
names(df)
str(df)
summary(df)
```
The median contribution is $`r median(df$amount)` but the average is $`r round(mean(df$amount))`. Most contributions were made by males or democrats.

```{r echo=FALSE, message=FALSE, warning=FALSE}
ggplot(data = df, aes(x = amount)) +
  geom_histogram(binwidth = 250) +
  scale_x_continuous(breaks = c(0, 1000, 2500, 5000, 10000, 15000))
```

We have long-tailed data. There are so many contributions made under $1,000 that it's hard to see any of the outliers.

```{r echo=FALSE, message=FALSE, warning=FALSE}
ggplot(data = df, aes(x = amount)) +
  geom_histogram() +
  scale_x_log10(breaks = c(10, 100, 1000))
```

A logarithmic transformation of the x-axis reveals something of a log-normal distribution with what could be a mean of $100. Even so, we can see that the distribution is heavier below this mean.

```{r echo=FALSE, message=FALSE, warning=FALSE}
ggplot(data = df, aes(x = amount)) +
  geom_histogram(binwidth = 50) +
  xlim(0, 3000)
```

There are a significant group of people (`r nrow(subset(df, amount == 2500))`) that, despite the long-tailed distribution, contribute $2,500.

```{r echo=FALSE, message=FALSE, warning=FALSE}
ggplot(data = df, aes(x = amount)) +
  geom_histogram(binwidth = 1) +
  xlim(0, 300)
```

Looking closer we can see that there appear to be several discrete values in increments of $50 that people are accustomed to contributing.

```{r echo=FALSE, message=FALSE, warning=FALSE}
ggplot(data = df, aes(x = amount)) +
  geom_histogram(binwidth = 1) +
  scale_x_continuous(limits = c(0, 60), breaks = seq(0, 60, 5))
```

Under $60, we can see contributions spaced in intervals of $5.

```{r echo=FALSE, message=FALSE, warning=FALSE}

ggplot(data = df, aes(x = as.factor(year(date)))) +
  geom_bar()
```

An overwhelming majority of contributions (`r round(100* table(year(df$date))[2]/sum(table(year(df$date))), 1)`%) were made in 2012.

```{r echo=FALSE, message=FALSE, warning=FALSE}
ggplot(data = df, aes(x = month(date, label=TRUE))) +
  geom_bar()
```

We can see a steady increase in contributions leading up to the election in November.

```{r echo=FALSE, message=FALSE, warning=FALSE}
ggplot(data = df, aes(x = as.factor(day(date)))) +
  geom_bar() +
  scale_x_discrete(breaks = seq(0, 31, 1))
```

There seems to be a slight increase in the amount of contributions made toward the end of the month. There is also a peak at about halfway through the month. People might be making contributions immediately after receiving their paychecks.

```{r echo=FALSE, message=FALSE, warning=FALSE}
ggplot(data = subset(df, !is.na(gender)), aes(x = gender)) +
  geom_bar()
```

Although a significant difference between the amount of male and female contributions, the proportion (`r round(nrow(subset(df, gender == "male")) / nrow(subset(df, !(is.na(gender)))), 2)` in favor of males) of the gap is not very large.

```{r echo=FALSE, message=FALSE, warning=FALSE}
p1 <- ggplot(data = df, aes(x = candidate)) +
  geom_bar() +
  theme(axis.text.x = element_text(angle=90))
p2 <- ggplot(data = df, aes(x = candidate)) +
  geom_bar() +
  scale_y_log10() +
  theme(axis.text.x = element_text(angle=90))
grid.arrange(p1, p2, nrow = 1)
```

Most contributions are made to either Obama or Romney. Using a log scale we can see the other candidates a little better.  There are a significant amount of contributions made to other candidates but they are mostly Republican. It would probably be better to use party instead of candidate as a predictor.

```{r echo=FALSE, message=FALSE, warning=FALSE}
ggplot(data = df, aes(x = party)) +
  geom_bar()
```
The proportion of contributions to democrats vs. republicans seems to resemble the proportion in the previous histrogram between Obama and Romney. This would make sense as the number of contributions to other candidates is small in comparison to these two. Also, the amount of contributions to the green party is so small (`r nrow(subset(df, party == 'green'))` contributions) that we might want to exclude for simplicity.  
  
It's important to remember that the remaining demographic variables correspond to the contributor's zipcode and not to the contributor him/herself.
```{r echo=FALSE, message=FALSE, warning=FALSE}
ggplot(data = df, aes(x = population)) +
  geom_histogram()
```

```{r echo = FALSE}
options(scipen=999)
```

The distribution of population in which contributors live is fairly normal with mean `r round(mean(df$population, na.rm = TRUE))` and median `r median(df$population, na.rm = TRUE)`.

```{r echo=FALSE, message=FALSE, warning=FALSE}
p1 <- ggplot(data = df, aes(x = pcnt_wht)) +
  geom_histogram()
p2 <- ggplot(data = df, aes(x = pcnt_blk)) +
  geom_histogram()
p3 <- ggplot(data = df, aes(x = pcnt_asn)) +
  geom_histogram()
p4 <- ggplot(data = df, aes(x = pcnt_hsp)) +
  geom_histogram()
grid.arrange(p1, p2, p3, p4, nrow = 2)
```

Most contributors live in areas with a high percentage of white ethnicity and a very low percentage of black, asian, or hispanic ethnicity.

```{r echo=FALSE, message=FALSE, warning=FALSE}
ggplot(data = df, aes(x = percap_incm)) +
  geom_histogram()
```

The distribution of per capita income in which contributors live is fairly normal with most living in zipcodes with a range of per capita income of about $20,000 - $40,000. The average is $`r round(mean(df$percap_incm, na.rm = TRUE))` and the median is $`r median(df$percap_incm, na.rm = TRUE)`.

```{r echo=FALSE, message=FALSE, warning=FALSE}
ggplot(data = df, aes(x = med_rent)) +
  geom_histogram()
```

Again, we see a fairly normal distribution of median rent in the locations in which contributors live. Rent is very cheap (median of $`r median(df$med_rent, na.rm = TRUE)`) as compared to California but per capita income is also lower.

```{r echo=FALSE, message=FALSE, warning=FALSE}
ggplot(data = df, aes(x = med_age)) +
  geom_histogram()
```

The median age in which contributors live also resembles a normal distrubtion with median `r median(df$med_age, na.rm = TRUE)`  

```{r echo=FALSE, message=FALSE, warning=FALSE}
total_cont <- df %>% group_by(zipcode) %>% summarise(count = n())
mapdata.ohio.cont <- merge(mapdata.ohio, total_cont,
                           by.x = 'region', by.y = 'zipcode',
                           all.x = TRUE) %>% arrange(order)
ggplot(data = mapdata.ohio.cont, aes(x = long, y = lat, group = group)) +
  geom_polygon(aes(fill = cut_number(count, 8))) +
  geom_path(colour = 'lightgray') +
  scale_fill_brewer('Total Contributions', palette  = 'Greys') +
  #coord_map() +
  theme_gray()
```

A choropleth map of total contributions by zipcode shows that there are hotspots of contributions. Because the zipcodes are so small in these hotspots we might assume that they are cities.

```{r echo=FALSE, message=FALSE, warning=FALSE}
# this first plot will size a city bubble based upon it's population
# but it may be visually overwhelming.
if(FALSE){
ggplot(data = mapdata.ohio.cont, aes(x = long, y = lat, group = group)) +
  geom_polygon(aes(fill = cut_number(count, 8))) +
  geom_path(colour = 'lightgray', linestyle = 2) +
  geom_point(data = mapdata.ohio.cities,
             aes(x = city_long, y = city_lat,
                 size = city_pop, group = NULL),
             color = 'green', alpha = 0.4) +
  geom_text(data = mapdata.ohio.cities,
            aes(x = city_long, y = city_lat, group = NULL),
                label = city_names, size = 3, color = 'black', alpha = 1,
            hjust = 1, vjust = -2, fontface = 2) +
  scale_size_continuous(range = c(10, 25)) +
  scale_fill_brewer('Total Contributions', palette  = 'YlOrRd') +
  #coord_map() +
  theme_minimal()
}
ggplot(data = mapdata.ohio.cont, aes(x = long, y = lat, group = group)) +
  geom_polygon(aes(fill = cut_number(count, 8))) +
  geom_path(colour = 'lightgray') +
  geom_point(data = mapdata.ohio.cities,
             aes(x = city_long, y = city_lat, group = NULL),
             size = 2, color = 'red') +
  geom_text(data = mapdata.ohio.cities,
            aes(x = city_long, y = city_lat, group = NULL),
                label = city_names, size = 3, color = 'red', alpha = 1,
            hjust = 1, vjust = -2, fontface = 2) +
  scale_size_continuous(range = c(10, 25)) +
  scale_fill_brewer('Total Contributions', palette  = 'Greys') +
  theme_minimal()
```

With an overlay of city location, we can see that total contributions are higher nearest to cities.

```{r echo=FALSE, message=FALSE, warning=FALSE}
popltn <- demographics.ohio %>% dplyr::select(region, total_population)
mapdata.ohio.pop <- merge(mapdata.ohio, popltn) %>% arrange(order)
ggplot(data = mapdata.ohio.pop, aes(x = long, y = lat, group = group)) +
  geom_polygon(aes(fill = cut_number(total_population, 8))) +
  geom_path(colour = 'lightgray', linestyle = 2) +
  scale_fill_brewer('Total Population', palette  = 'Greys') +
  #coord_map() +
  theme_gray()
```

A map of total population per zipcode is definitely similar to the map of total contributions but it doesn't seem like an exact match. It could be that the higher the population in a zipcode, the more contributions are made. There may also be more contributions made from affluent suburbs with higher per capita income regardless of total population.


# Univariate Analysis

### What is the structure of your dataset?
There are 151,479 instances of campaign contribution in the dataset with 19 features.  From the original data set 11 features were kept or derived:  

* candidate
* name (contributor)
* city
* state
* zipcode
* employer
* occupation
* amount
* date
* gender
* party

Using the zipcode feature, demographic information was added from another data set:  

* total_population
* percent_white
* percent_black
* percent_asian
* percent_hispanic
* per_capita_income
* median_rent
* median_age

From the original data set, all but name, amount, and date are factors. None of the factors are ordered. Name is a character, amount is numeric, and date is a date object. The 8 demographic features are all numeric.  

Other observations:  

* The largest group of contributors by occupation are retirees
* About 60% of contributions are made by democrats
* The median contribution amount is $50 and the maximum is $15,000
* Barack Obama received 60% of contributions
* Women accounted for 45% of contributors
* The number of monthly contributions show an exponential increase as the election approaches

### What is/are the main feature(s) of interest in your dataset?
The main features of interest in the data set are amount, gender, party, per capita income, and median age. I would like to see if these factors are correlated with contribution amount. Occupation could be of interest however there are too many levels (6,846).

### What other features in the dataset do you think will help support your investigation into your feature(s) of interest?
I believe that the percent ethnicities, total population, and median rent may be correlated with contribution amount.

### Did you create any new variables from existing variables in the dataset?
I created two new variables, one for the gender of the contributor based upon the first name, and another for the party of the contributor based upon the candidate that received the contribution. I was unable to programatically determine gender by first name for about 4,742 instances (approx. 3% of the data).

### Of the features you investigated, were there any unusual distributions? Did you perform any operations on the data to tidy, adjust, or change the form of the data? If so, why did you do this?
A log transformation of contribution amount revealed a log-normal distribution. Despite this, we can see in the non-skewed distribution that there are a significant group of people that donate the maximum allowable campaign contribution by law (approx. $2,600). There are also Political Action Committee (PAC) data in the set which have a larger limit (approx. $5,000). I am unsure of the validity of the outliers beyond this amount because of my limited knowledge of campaign finance law. That there were several negative amounts which needed to be corrected to positive leads me to believe that there could be further inaccuracies in the data set.  
The data came in a tidy format and did not need to be transformed.

# Bivariate Plots Section
```{r echo=FALSE, message=FALSE, warning=FALSE, Bivariate_Plots1}
# add time as numeric date variable
df$time <- as.numeric(as.POSIXct(df$date, format="%Y-%m-%d %H:%M:%S"))
#names(df[, c(8, 12:20)])
cor(df[, c(8, 12:20)], use = "complete.obs")
```

None of the numeric variables seem to be strongly correlated with amount although all are significantly correlated with it (absolute value greater than 3%). Despite the increase in contributions towards the election, the amount is negatively correlated with increasing time.

```{r pairs_plot, cache=TRUE, cache.path='cache/', fig.path='figure/', echo=FALSE, message=FALSE, warning=FALSE}
pairs_df <- df[, c(8, 10:20)] %>% filter(!(is.na(gender)), party != "green")
pairs_plt = ggpairs(pairs_df, color = "gender",
                      columnLabels = c("amt", "gndr", "prty", "pop",
                                       "%w", "%b", "%a", "%h",
                                       "inc", "rnt", "age", "tm"),
                      params=list(size=2))
print(pairs_plt, left = 0.75, bottom = 0.75)
```
  
The factored variables of gender and party were not included in the correlation analysis or pairs plot so we should take a closer look at these.

```{r echo=FALSE, message=FALSE, warning=FALSE}
ggplot(data = subset(df, !(is.na(gender))),
       aes(x = gender, y = amount, fill = gender)) +
  geom_boxplot() +
  scale_fill_brewer(type = 'qual') +
  coord_cartesian(ylim = c(0, 750))
```

The mean contribution amount as well as the IQ range is larger for males than females.

```{r echo=FALSE, message=FALSE, warning=FALSE}
ggplot(data = subset(df, party != "green"),
       aes(x = party, y = amount, fill = party)) +
  geom_boxplot() +
  scale_fill_manual(values = c('#377eb8', '#e41a1c')) +
  coord_cartesian(ylim = c(0, 750))
```

The mean contribution amount as well as the IQ range is larger for republicans than democrats.   

   
The following are plots of variables of interest by amount with correlation statistics.

```{r echo=FALSE, message=FALSE, warning=FALSE}
ggplot(data = df, aes(x = percap_incm, y = amount)) +
  geom_jitter(color = 'green', alpha = 0.05) +
  geom_smooth(method = 'lm', color = 'blue') +
  geom_smooth(color = 'red') +
  coord_cartesian(ylim = c(0, 3000))
cor(df$percap_incm, df$amount, use = "complete.obs")
```

```{r echo=FALSE, message=FALSE, warning=FALSE}
ggplot(aes(y = amount, x = date), data = df) +
  geom_jitter(color = 'yellow', alpha = 0.05) +
  geom_smooth(method = 'lm', color = 'blue') +
  geom_smooth(color = 'red') +
  coord_cartesian(ylim = c(0, 3000))
cor(df$time, df$amount, use = "complete.obs")
```

```{r echo=FALSE, message=FALSE, warning=FALSE}
ggplot(aes(y = amount, x = med_age), data = df) +
  geom_jitter(color = 'orange', alpha = 0.05) +
  geom_smooth(method = 'lm', color = 'blue') +
  geom_smooth(color = 'red') +
  coord_cartesian(ylim = c(0, 3000))
cor(df$med_age, df$amount, use = "complete.obs")
```

```{r echo=FALSE, message=FALSE, warning=FALSE}
ggplot(aes(y = amount, x = med_rent), data = df) +
  geom_jitter(color = 'bisque', alpha = 0.05) +
  geom_smooth(method = 'lm', color = 'blue') +
  geom_smooth(color = 'red') +
  coord_cartesian(ylim = c(0, 3000))
cor(df$med_rent, df$amount, use = "complete.obs")
```

```{r echo=FALSE, message=FALSE, warning=FALSE}
ggplot(aes(y = amount, x = population), data = df) +
  geom_jitter(color = 'chartreuse', alpha = 0.05) +
  geom_smooth(method = 'lm', color = 'blue') +
  geom_smooth(color = 'red') +
  coord_cartesian(ylim = c(0, 3000))
cor(df$population, df$amount, use = "complete.obs")
```

```{r echo=FALSE, message=FALSE, warning=FALSE}
ggplot(aes(y = amount, x = pcnt_asn), data = df) +
  geom_jitter(color = 'violet', alpha = 0.05) +
  geom_smooth(method = 'lm', color = 'blue') +
  geom_smooth(color = 'red') +
  coord_cartesian(ylim = c(0, 3000))
cor(df$pcnt_asn, df$amount, use = "complete.obs")
```

```{r echo=FALSE, message=FALSE, warning=FALSE}
ggplot(aes(y = amount, x = pcnt_wht), data = df) +
  geom_jitter(color = 'turquoise', alpha = 0.05) +
  geom_smooth(method = 'lm', color = 'blue') +
  geom_smooth(color = 'red') +
  coord_cartesian(ylim = c(0, 3000))
cor(df$pcnt_wht, df$amount, use = "complete.obs")
```

```{r echo=FALSE, message=FALSE, warning=FALSE}
ggplot(aes(y = amount, x = pcnt_blk), data = df) +
  geom_jitter(color = 'salmon', alpha = 0.05) +
  geom_smooth(method = 'lm', color = 'blue') +
  geom_smooth(color = 'red') +
  coord_cartesian(ylim = c(0, 3000))
cor(df$pcnt_blk, df$amount, use = "complete.obs")
```

```{r echo=FALSE, message=FALSE, warning=FALSE}
ggplot(aes(y = amount, x = pcnt_hsp), data = df) +
  geom_jitter(color = 'gold', alpha = 0.05) +
  geom_smooth(method = 'lm', color = 'blue') +
  geom_smooth(color = 'red') +
  coord_cartesian(ylim = c(0, 3000))
cor(df$pcnt_hsp, df$amount, use = "complete.obs")
```

Despite some significant correlation values here, they are difficult to see when plotted. I think that these relationship are very weak as far as being able to predict contribution amount.

```{r echo=FALSE, message=FALSE, warning=FALSE}
ggplot(aes(y = amount, x = as.factor(year(date))), data = df) +
  geom_boxplot() +
  coord_cartesian(ylim = c(0, 500))
```

Here we can see that contributions early on tend to be larger and with a greater range. The data for 2011 contributions is also much smaller than for 2012 so this may be a factor.

```{r echo=FALSE, message=FALSE, warning=FALSE}
ggplot(aes(y = amount, x = as.factor(month(date))), data = df) +
  geom_boxplot() +
  coord_cartesian(ylim = c(0, 1000))
ggplot(aes(y = amount, x = as.factor(day(date))), data = df) +
  geom_boxplot() +
  coord_cartesian(ylim = c(0, 1000))
```

Neither month nor day seem to correlate much with amount.

```{r echo=FALSE, message=FALSE, warning=FALSE}
avg_amount <- df %>% group_by(zipcode) %>%
  summarise(avg.amount = mean(amount))
mapdata.ohio.avg_amount <- merge(mapdata.ohio, avg_amount,
                                 by.x = 'region', by.y = 'zipcode',
                                 all.x = TRUE) %>% arrange(order)
ggplot(data = mapdata.ohio.avg_amount, aes(x = long, y = lat, group = group)) +
  geom_polygon(aes(fill = cut_number(avg.amount, 8))) +
  geom_path(colour = 'lightgray', linestyle = 2) +
  scale_fill_brewer('Average Amount', palette  = 'Greens') +
  #coord_map() +
  theme_minimal()
```

In this choropleth map, the location of the population centers are not as apparent. Average contribution amount doesn't seem to correlate with a city center as much as total contributions.

```{r echo=FALSE, message=FALSE, warning=FALSE}
ggplot(data = mapdata.ohio.avg_amount, aes(x = long, y = lat, group = group)) +
  geom_polygon(aes(fill = cut_number(avg.amount, 8))) +
  geom_path(colour = 'lightgray', linestyle = 2) +
  geom_point(data = mapdata.ohio.cities,
             aes(x = city_long, y = city_lat, group = NULL),
             size = 2, color = 'magenta') +
  geom_text(data = mapdata.ohio.cities,
            aes(x = city_long, y = city_lat, group = NULL),
                label = city_names, size = 3, color = 'magenta', alpha = 1,
            hjust = 1, vjust = -2, fontface = 2) +
  scale_size_continuous(range = c(10, 25)) +
  scale_fill_brewer('Average Amount', palette  = 'Greens') +
  #coord_map() +
  theme_minimal()
```

Here we can see the population centers.

```{r echo=FALSE, message=FALSE, warning=FALSE}
income <- demographics.ohio %>% dplyr::select(region, per_capita_income)
mapdata.ohio.income <- merge(mapdata.ohio, income) %>% arrange(order)
ggplot(data = mapdata.ohio.income, aes(x = long, y = lat, group = group)) +
  geom_polygon(aes(fill = cut_number(per_capita_income, 8))) +
  geom_path(colour = 'lightgray', linestyle = 2) +
  scale_fill_brewer('Per Capita Income', palette  = 'Oranges') +
  #coord_map() +
  theme_gray()
```

Average contribution amount may more closely resemble per capita income rather than total population. Higher values surround the city centers with something of a buffer. Also, there are some areas away from the city centers with high average contribution amount. These could be affluent rural areas or areas with little data.


```{r echo=FALSE, message=FALSE, warning=FALSE}
total_amt <- df %>% group_by(zipcode) %>%
  summarise(total.amount = sum(amount))
mapdata.ohio.total_amt <- merge(mapdata.ohio, total_amt,
                                by.x = 'region', by.y = 'zipcode',
                                all.x = TRUE) %>% arrange(order)
ggplot(data = mapdata.ohio.total_amt, aes(x = long, y = lat, group = group)) +
  geom_polygon(aes(fill = cut_number(total.amount, 8))) +
  geom_path(colour = 'lightgray', linestyle = 2) +
  scale_fill_brewer('Total Amount', palette  = 'Purples') +
  #coord_map() +
  theme_minimal()
```

Total amount of contribution per zipcode does again seem to correlate with city proximity.

```{r echo=FALSE, message=FALSE, warning=FALSE}
ggplot(data = mapdata.ohio.total_amt, aes(x = long, y = lat, group = group)) +
  geom_polygon(aes(fill = cut_number(total.amount, 8))) +
  geom_path(colour = 'lightgray', linestyle = 2) +
  geom_point(data = mapdata.ohio.cities,
             aes(x = city_long, y = city_lat, group = NULL),
             size = 2, color = 'green') +
  geom_text(data = mapdata.ohio.cities,
            aes(x = city_long, y = city_lat, group = NULL),
                label = city_names, size = 3, color = 'green', alpha = 1,
            hjust = 1, vjust = -2, fontface = 2) +
  scale_size_continuous(range = c(10, 25)) +
  scale_fill_brewer('Total Amount', palette  = 'Purples') +
  #coord_map() +
  theme_minimal()
```


# Bivariate Analysis

### Talk about some of the relationships you observed in this part of the investigation. How did the feature(s) of interest vary with other features in the dataset?
Relatively speaking, there were no strong relationship discovered in the numerical correlations. There were however significant correlations (abs. value > 3%) among all of the variables and amount. Per capita income had the strongest correlation (16%) followed by time (numerical date), median age, median rent, total population, percent asian, percent white, percent black, and percent hispanic with the lowest (-3.25%).  
Time, total population, percent black, and percent hispanic were all negatively correlated. Among the ordered factors of gender and party, republican contributions were on average higher than democrat, as were male contributions higher than female. 

### Did you observe any interesting relationships between the other features (not the main feature(s) of interest)?
I did not expect that time and total population would be correlated with contribution amount. It appears that early on contributions are largest, which might make sense to support a candidate for a longer campaign. Total population seems a bit arbitrary as zipcodes are not necessarily zoned for equal area.

### What was the strongest relationship you found?
The strongest relationship among all the variables was that between percent white and percent black of a contributors location. These are negatively correlated at 97%. Among the variables of interest the strongest correlation was between per capita income and amount which I suspected to be so.


# Multivariate Plots Section

```{r echo = FALSE}
ggplot(aes(x = party, fill = gender),
       data = subset(df, !(is.na(gender)) & party != "green")) +
  geom_histogram(position = "dodge") +
  scale_fill_brewer(type = 'qual')
```

Contributions to the Democratic party came from a slight female majority whereas contributions to the Republican party came from an overwhelming male majority.


```{r echo=FALSE, message=FALSE, warning=FALSE, Bivariate_Plots2}
ggplot(aes(x = amount, fill = gender), data = subset(df, party != "green")) +
  geom_histogram(position = "dodge") +
  scale_fill_brewer(type = 'qual') +
  scale_x_log10() +
  facet_wrap(~party, ncol = 1)

# easier to interpret with 'dodge' than with histogram overlay below...
if(FALSE) {
ggplot(aes(x = amount), data = subset(df, party != "green")) +
  geom_histogram(aes(fill = gender)) +
  scale_fill_brewer(type = 'qual') +
  scale_x_log10() +
  facet_wrap(~party)
}
```

Although a relatively small proportion, males tend to contribute slightly more at higher amounts to the Democratic party than females. There appears to be no caveat for the Republican party (males make more contributions at all amounts). Also, at higher amounts, Republicans make more contributions than Democrats.  


Plotting relationships between variables of interest and amount by gender and party. Each plot contains both a LOESS and LM smoothing method.

```{r echo=FALSE, message=FALSE, warning=FALSE, Multivariate_Plots}
p1 <- ggplot(data = subset(df, !(is.na(gender))),
       aes(x = percap_incm, y = amount, color = gender)) +
  scale_color_brewer(type = 'qual') +
  geom_smooth() + geom_smooth(method = 'lm')

p2 <- ggplot(data = subset(df, party != "green"),
       aes(x = percap_incm, y = amount, color = party)) +
  scale_color_manual(values = c('#377eb8', '#e41a1c')) +
  geom_smooth() + geom_smooth(method = 'lm')

grid.arrange(p1, p2, ncol = 2)
```

The positive correlation between contribution amount and per capita income seems to be much more pronounced with Republicans than Democrats.

```{r echo=FALSE, message=FALSE, warning=FALSE}
p1 <- ggplot(data = subset(df, !(is.na(gender))),
       aes(x = date, y = amount, color = gender)) +
  scale_color_brewer(type = 'qual') +
  geom_smooth() + geom_smooth(method = 'lm')

p2 <- ggplot(data = subset(df, party != "green"),
       aes(x = date, y = amount, color = party)) +
  scale_color_manual(values = c('#377eb8', '#e41a1c')) +
  geom_smooth() + geom_smooth(method = 'lm')

grid.arrange(p1, p2, ncol = 2)
```

Both males and Republicans seem to 'rally' behind their candidate leading up to election time with an increase in contribution amount as compared to their female or Democrat counterparts.

```{r echo=FALSE, message=FALSE, warning=FALSE}
p1 <- ggplot(data = subset(df, !(is.na(gender))),
       aes(x = med_age, y = amount, color = gender)) +
  scale_color_brewer(type = 'qual') +
  geom_smooth() + geom_smooth(method = 'lm')

p2 <- ggplot(data = subset(df, party != "green"),
       aes(x = med_age, y = amount, color = party)) +
  scale_color_manual(values = c('#377eb8', '#e41a1c')) +
  geom_smooth() + geom_smooth(method = 'lm')

grid.arrange(p1, p2, ncol = 2)
```

Although this demographic information does not necessarily reflect the contributor, both Republicans and males show a stronger positive correlation between median age of their locale and personal contribution amount than do their female or Democrat counterparts.

```{r echo=FALSE, message=FALSE, warning=FALSE}
p1 <- ggplot(data = subset(df, !(is.na(gender))),
       aes(x = med_rent, y = amount, color = gender)) +
  scale_color_brewer(type = 'qual') +
  geom_smooth() + geom_smooth(method = 'lm')

p2 <- ggplot(data = subset(df, party != "green"),
       aes(x = med_rent, y = amount, color = party)) +
  scale_color_manual(values = c('#377eb8', '#e41a1c')) +
  geom_smooth() + geom_smooth(method = 'lm')

grid.arrange(p1, p2, ncol = 2)
```

Median rent by party is similar to per capita income by party.

```{r echo=FALSE, message=FALSE, warning=FALSE}
p1 <- ggplot(data = subset(df, !(is.na(gender))),
       aes(x = population, y = amount, color = gender)) +
  scale_color_brewer(type = 'qual') +
  geom_smooth() + geom_smooth(method = 'lm')

p2 <- ggplot(data = subset(df, party != "green"),
       aes(x = population, y = amount, color = party)) +
  scale_color_manual(values = c('#377eb8', '#e41a1c')) +
  geom_smooth() + geom_smooth(method = 'lm')

grid.arrange(p1, p2, ncol = 2)
```

Population by gender or party does not give us much more insight.

```{r echo=FALSE, message=FALSE, warning=FALSE}
p1 <- ggplot(data = subset(df, !(is.na(gender))),
       aes(x = pcnt_asn, y = amount, color = gender)) +
  scale_color_brewer(type = 'qual') +
  geom_smooth() + geom_smooth(method = 'lm')

p2 <- ggplot(data = subset(df, party != "green"),
       aes(x = pcnt_asn, y = amount, color = party)) +
  scale_color_manual(values = c('#377eb8', '#e41a1c')) +
  geom_smooth() + geom_smooth(method = 'lm')

grid.arrange(p1, p2, ncol = 2)
```

```{r echo=FALSE, message=FALSE, warning=FALSE}
p1 <- ggplot(data = subset(df, !(is.na(gender))),
       aes(x = pcnt_wht, y = amount, color = gender)) +
  scale_color_brewer(type = 'qual') +
  geom_smooth() + geom_smooth(method = 'lm')

p2 <- ggplot(data = subset(df, party != "green"),
       aes(x = pcnt_wht, y = amount, color = party)) +
  scale_color_manual(values = c('#377eb8', '#e41a1c')) +
  geom_smooth() + geom_smooth(method = 'lm')

grid.arrange(p1, p2, ncol = 2)
```

```{r echo=FALSE, message=FALSE, warning=FALSE}
p1 <- ggplot(data = subset(df, !(is.na(gender))),
       aes(x = pcnt_blk, y = amount, color = gender)) +
  scale_color_brewer(type = 'qual') +
  geom_smooth() + geom_smooth(method = 'lm')

p2 <- ggplot(data = subset(df, party != "green"),
       aes(x = pcnt_blk, y = amount, color = party)) +
  scale_color_manual(values = c('#377eb8', '#e41a1c')) +
  geom_smooth() + geom_smooth(method = 'lm')

grid.arrange(p1, p2, ncol = 2)
```

```{r echo=FALSE, message=FALSE, warning=FALSE}
p1 <- ggplot(data = subset(df, !(is.na(gender))),
       aes(x = pcnt_hsp, y = amount, color = gender)) +
  scale_color_brewer(type = 'qual') +
  geom_smooth() + geom_smooth(method = 'lm')

p2 <- ggplot(data = subset(df, party != "green"),
       aes(x = pcnt_hsp, y = amount, color = party)) +
  scale_color_manual(values = c('#377eb8', '#e41a1c')) +
  geom_smooth() + geom_smooth(method = 'lm')

grid.arrange(p1, p2, ncol = 2)
```

The percent ethnicities seem to show erratic trends with LOESS.

```{r echo=FALSE, message=FALSE, warning=FALSE}
amt_person <- merge(popltn, total_amt,
                    by.x = 'region', by.y = 'zipcode', all.x = TRUE)
amt_person <- subset(amt_person, !(is.na(total.amount))) %>%
  mutate(amt_per_person = total.amount / total_population) %>%
  dplyr::select(region, amt_per_person)

mapdata.ohio.amt_person <- merge(mapdata.ohio, amt_person, all.x = TRUE) %>%
  arrange(order)

ggplot(data = mapdata.ohio.amt_person, aes(x = long, y = lat, group = group)) +
  geom_polygon(aes(fill = cut_number(amt_per_person, 8))) +
  geom_path(colour = 'lightgray', linestyle = 2) +
  geom_point(data = mapdata.ohio.cities,
             aes(x = city_long, y = city_lat,
                 group = NULL), color = 'green', size = 2) +
  scale_fill_brewer('Amount Per Person', palette  = 'Blues') +
  #coord_map() +
  theme_minimal()

if(FALSE) {
total_amt_dem <- subset(df, party == 'democrat') %>% group_by(zipcode) %>%
  summarise(total.amount = sum(amount))
mapdata.ohio.total_amt_dem <- merge(mapdata.ohio, total_amt_dem,
                                    by.x = 'region', by.y = 'zipcode',
                                    all.x = TRUE) %>% arrange(order)
ggplot(data = mapdata.ohio.total_amt_dem, aes(x = long, y = lat,
                                              group = group)) +
  geom_polygon(aes(fill = cut_number(total.amount, 8))) +
  geom_path(colour = 'lightgray', linestyle = 2) +
  scale_fill_brewer('Total Amount', palette  = 'Blues') +
  coord_map() +
  theme_minimal()

total_amt_rep <- subset(df, party == 'republican') %>% group_by(zipcode) %>%
  summarise(total.amount = sum(amount))
mapdata.ohio.total_amt_rep <- merge(mapdata.ohio, total_amt_rep,
                                    by.x = 'region', by.y = 'zipcode',
                                    all.x = TRUE) %>% arrange(order)
ggplot(data = mapdata.ohio.total_amt_rep, aes(x = long, y = lat,
                                              group = group)) +
  geom_polygon(aes(fill = cut_number(total.amount, 8))) +
  geom_path(colour = 'lightgray', linestyle = 2) +
  scale_fill_brewer('Total Amount', palette  = 'Reds') +
  coord_map() +
  theme_minimal()
}
```

Contribution amount per person seems to more closely resemble the map of average contribution amount rather than total contributions.

```{r echo=FALSE, message=FALSE, warning=FALSE, Build_Linear_Model}
model_df <- df[, c(8, 10:20)]
model_df <- subset(model_df, amount != 0 & party != 'green')
model_df <- na.omit(model_df)

m1 <- lm(I(log(amount)) ~ I(percap_incm),
         data = subset(model_df, amount < 2700))
m2 <- update(m1, ~ . + gender)
m3 <- update(m1, ~ . + party)
mtable(m1, m2, m3)

#thisDonation <- head(model_df)[3,c(9,2,3)]
#thisDonation <- head(model_df)[1,c(9,2,3)]
#thisDonation <- head(model_df)[2,c(9,2,3)]
#modelEstimate = predict(m3, newdata = thisDonation,
#                        interval="prediction", level = .95)
# To get the real amount value, we need to exponentiate the modelEstimate...
#exp(modelEstimate)
```
Our best model only accounts for about 18% of the variation in donation amount.

# Multivariate Analysis

### Talk about some of the relationships you observed in this part of the investigation. Were there features that strengthened each other in terms of looking at your feature(s) of interest?
I looked at amount against all of the significantly correlated features but adding in gender and/or party as a third variable. In nearly all of the comparisons gender and party proved to be a significant in differentiating total contribution amount. Specifically, contribution amount was higher for males than females as was it for Republicans versus Democrats. Also, because of the majority male constituency for Republican doners, we see that male trends generally mirror Republican trends as do female trends mirror Democratic trends. 

### Were there any interesting or surprising interactions between features?
I knew that gender and party might be significant factors but I did not know to what extent (these features could not be analyzed in the correlation table). I was somewhat surprised to see that differences in gender and party were universal across all other features with respect to contribution amount. An interesting finding was that Democratic contribution amounts show little increase with increasing per capita income of the contributors demographic as compared to Republican contribution amounts. Also, looking at contribution amount over time by party showed that, despite both parties having larger contribution amounts earlier on, Republicans increased their contribution amount leading up to the election whereas Democrats do not. The same is true for males over females but the relationship is less pronounced. This sort of last minute increase in contribution amount reminds me of a type of rally behavior. Whether or not this is effective in catapulting a candidate to nomination is a whole other question altogether but I doubt it to be so (especially since Romney lost Ohio in 2012). Another interesting difference between males and females is that as the median age of the demographic of the contributor increases, male contribution amount tends to increase whereas female contribution shows a slight decrease. The same idea applies for Republicans and Democrats, Republicans showing an increase in amount as the median age of the contributor's zipcode increases but holding steady for Democrats. If median age of the contributors zipcode did in fact reflect the actual age of the contributor, we could hypothesize that females are less inclined to donate large amounts as they get older.

### OPTIONAL: Did you create any models with your dataset? Discuss the strengths and limitations of your model.
I experimented with several different models and found that one which modeled the log of amount with per capita income, gender, and party was the most effective in explaining variance in contribution amount. I tried to include time as a factor because it was highly negatively correlated with amount however adding this feature only decreased the R-squared value. Adding all of the remaining significantly correlated features had the same effect to decrease the R-squared value.

------

# Final Plots and Summary

### Plot One
```{r echo=FALSE, message=FALSE, warning=FALSE, Plot_One}
p1 <- ggplot(data = df, aes(x = amount)) +
  geom_histogram() +
  scale_x_log10(breaks = c(10, 100, 1000)) +
  ggtitle('Contribution Amount Distribution') +
  xlab('Log10 Amount (in dollars)') + 
  ylab('Number of Contributions')
p2 <- ggplot(data = df, aes(x = month(date, label=TRUE))) +
  geom_histogram() +
  ggtitle('Contribution by Month') +
  xlab('Contribution Month') + 
  ylab('Number of Contributions')
grid.arrange(p1, p2, ncol = 2)
```

### Description One
The first plot shows both how contribution amounts are distributed log-normally and how contributions increase leading up to an election.

### Plot Two
```{r echo=FALSE, message=FALSE, warning=FALSE, Plot_Two}
p1 <- ggplot(aes(x = party, fill = gender),
       data = subset(df, !(is.na(gender)) & party != "green")) +
  scale_fill_brewer(type = 'qual') +
  geom_histogram(position = "dodge") +
  ggtitle('Contributions by Party and Gender') +
  xlab('Party') + 
  ylab('Contributions')
p2 <- ggplot(data = subset(df, !(is.na(gender))),
       aes(x = percap_incm, y = amount, color = gender)) +
  scale_color_brewer(type = 'qual') +
  geom_smooth() +
  ggtitle('Amount by Income and Gender') +
  xlab('Per Capita Income') + 
  ylab('Amount (dollars)')
p3 <- ggplot(data = subset(df, party != "green"),
       aes(x = percap_incm, y = amount, color = party)) +
  scale_color_manual(values = c('#377eb8', '#e41a1c')) +
  geom_smooth() +
  ggtitle('Amount by Income and Party') +
  xlab('Per Capita Income (dollars)') + 
  ylab('Amount (dollars)')
p4 <- ggplot(data = subset(df, party != "green"),
       aes(x = date, y = amount, color = party)) +
  scale_color_manual(values = c('#377eb8', '#e41a1c')) +
  geom_smooth() +
  ggtitle('Amount by Date and Party') +
  xlab('Date') + 
  ylab('Amount (dollars)')
grid.arrange(p1, p2, p3, p4, nrow = 2)
```

### Description Two
This plot grid shows that, in Ohio, most Democratic contributions were made by females and an overwhelming majority of Republican contributions were made by males. Also that, in general, Republican and male contribution amounts are higher than Democrat and female contribution amounts. An interesting rally phenomenon can be seen here with Republican party as the election date approaches.

### Plot Three
```{r echo=FALSE, message=FALSE, warning=FALSE, Plot_Three}
ggplot(data = mapdata.ohio.avg_amount, aes(x = long, y = lat, group = group)) +
  geom_polygon(aes(fill = cut_number(avg.amount, 8)), alpha = 0.8) +
  geom_path(colour = 'lightgray', linestyle = 2) +
  geom_point(data = mapdata.ohio.cities,
             aes(x = city_long, y = city_lat, group = NULL),
             size = 2, color = 'blue') +
  geom_text(data = mapdata.ohio.cities,
            aes(x = city_long, y = city_lat, group = NULL),
                label = city_names, size = 3.5, color = 'blue',
            hjust = 1.25, vjust = -1, fontface = 2) +
  scale_size_continuous(range = c(10, 25)) +
  scale_fill_brewer('Average Amount (dollars)', palette  = 'YlOrRd') +
  #coord_map() +
  theme_minimal() +
  ggtitle('Average Contribution Amount by Location')
```

### Description Three  

This final plot shows that, despite total contribution amount being highly correlated with city center, average contribution amount is highest surrounding a city and also in some rural areas. This may shed light on why presidential candidates spend a significant amount of time campaigning in suburbs and seemingly rural areas.

------

# Reflection
In my investigation of 2012 Presidential Campaign Contributions for the state of Ohio, I chose to focus on finding the most significant features of a contributors information that could be used to predict the actual contribution amount. The most significant features proved to be per capita income of the area in which the contributor lives (which we can assume gives an idea of the contributor him or herself), the gender of the contributor, and the political party affiliation of the contributor (simplified to be either Democrat or Republican). Per capita income of the contributor's zipcode has a positive correlation with the contributor's contribution amount. Males have on average higher contribution amounts than females as do Republicans versus Democrats. This would lead one to conclude that given these correlated features, the highest contribution amount could belong to a male Republican who lives in an area with high per capita income. The lowest contribution amount might belong to a contributor who is a female Democrat and who lives in an area with a low per capita income.

Despite these findings, the model that was developed was only able to account for about 18% of the variation in contribution amount. It would have been great to have actual income, age, and ethnicity of the contributor him/herself. I believe that these would have had a much higher correlation than the demographic information of the contributors zipcode. The demographic information was at best a rough approximation of the contributor.

With regard to the choropleth maps, it seemed apparent that total contributions and total contribution amount were highly correlated with city proximity. Average contribution appeared to be higher closer to cities, but with a buffer between the actual city center and high average contribution amounts.

There are several shortcomings of the data set. First, I question the validity of some of the information as several contribution amounts had to be changed from negative to positive. Second, as compared to other zipcodes, some lacked a substantial amount of data. This may have skewed the average contribution choropleth map. Another shortcoming was the inability to programatically determine the gender by first name of the contributor for about 4% of the data. I had a difficult time with regex in R, were I more adept at this, that data might have been included.

If possible, further analysis could include distance, or some measure of proximity, to a city center. The choropleth maps that were generated attempted to show a spatial relationship between amount and cities. This was however at best an approximation without any concrete measurements to back-up the claims/insights. To do this, an average latitude and longitude value could be calculated and added as a variable for each zipcode, and another variable could be added for distance to the closest city.
