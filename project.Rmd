---
title: "Ohio 2012 Presidential Campaign Contributions by Christopher B. Winkelman"
output:
  html_document:
    fig_width: 10
    fig_height: 7
    toc: true
    toc_depth: 1
    toc_float: true
    number_sections: true
    theme: united
    highlight: tango
    code_folding: hide
---

========================================================

```{r packages, echo=FALSE, message=FALSE, warning=FALSE}
# both choropleth map data and gender data may need installing.
# url of data was changed so cannot download.
library(readr)
#install.packages("devtools")
#library(devtools)
#install_github('arilamstein/choroplethrZip@v1.3.0')
library(choroplethrZip)
library(ggplot2)
library(stringr)
library(dplyr)
library(tidyr)
library(zipcode)
#install.packages("genderdata")
library(gender)
library(rvest)
library(lubridate)
library(gridExtra)
library(RColorBrewer)
library(ggthemes)
library(polycor)
#library(GGally)
library(memisc)
library(scales)
library(ggfortify)
#download.file()

# note that the first 2 sections of loading and manipulating
# the data can be skipped.
# tidy data sets can be sourced from the last chunk of
# the 'data manipulation' section from the '.Rdata' file.
```

# Introduction

This is an exploratory data analysis of campaign contributions for the state of Ohio during the 2012 presidential election.  Historically, Ohio has been a critical swing state for presidential elections and, according to wikipedia, possesses the longest streak of matching the overall election outcome (since 1960).  It would be a mistake to infer that campaign contributions are a predictor or even loosely correlated with votes (I might be biting my tongue if we were talking about superPACs though), but Ohio is one of the most frequently visited states on a presidential nominee's campaign trail and for this reason it piqued my interest.   I'll explore the nature of campaign contributions and see if there are any interesting relationships in the data.  I'll also take a look at the geographic distribution of campaign contributions by zipcode.  This exploration may shed light on the characteristics of a generous contributor and perhaps why particular party candidates visit certain areas in the state.  Anything of significance could be used in future inferential or predictive analysis.

---

# Load Data

There are 3 data sets that will be used for this exploration:

- campaign contribution data
- geographic data (to generate maps)
- demographic data (to add features)

I'll link these datasets by zipcode much like tables in a database.  The geographic and demographic data come from a library and are already nicely formatted.  The features in the campaign contribution data, however, might need some explicit class declarations.

Let's peak at the first few rows to inspect the atomic classes (types).

```{r initial-error, echo=TRUE, eval=TRUE, error=TRUE}
df_look <- read.csv("campaign-contributions-ohio-2012.csv", nrows = 100)
```

While trying to read the file, there is some kind of error about the row names.  Let's explicitly set `row.names = NULL` to see if that fixes it.

```{r rownames-null, echo=1}
df_look <- read.csv("campaign-contributions-ohio-2012.csv",
                    nrows = 100, row.names=NULL)
head(df_look); rm(df_look)
```

By setting the row names to `NULL` we forced row numbering but for some reason it used an existing column as the row number. Using `head` to look at the first 6 lines, it seems like there is a mismatch between the header and the rest of the data.  Let's manually open a connection to the file and read a few lines including the header to see if we can pinpoint the problem.

```{r read-lines}
con <- file("campaign-contributions-ohio-2012.csv", "r")
lines <- readLines(con, 5); close(con); lines
```

It's difficult to tell from this output, but it looks like we have an extra empty column at the end of each row.  We could use `count.fields()` but that opens up the entire file.  Instead, let's create a smaller test file to do this.

```{r make-testfile}
con <- file("campaign-contributions-ohio-2012.csv", "r")
lines <- readLines(con, 20); close(con)
# using write.csv() here seems to cause problems with escape characters.
# using a connection object works better.
con <- file("test.csv"); writeLines(lines, con); close(con)
count.fields("test.csv", sep = ",")
```

This confirms that the data following the header somehow has an extra field. Looking back at the results from `head` and `readlines`, we can see that the extra field is full of NAs and it's caused by `","` at the end of each row.

We can fix this a few different ways.  We can set the row names to NULL again, shift the column names to the left, and then remove the last column from the dataframe.  Or, we can get the header row by itself and then use it as the column names for the rest of the data without that last empty column.  The second option seems easier so we'll go with that.  After, we can finally peak into the correctly structured data to see if we need to make any adjustments (like strings as factors).

```{r names-and-inspect, echo=-c(8)}
df_test_header <- read.csv("test.csv",
                     header = FALSE, stringsAsFactors = FALSE, nrows = 1)
column_names <- unname(unlist(df_test_header))
df_test_body <- read.csv("test.csv", header = FALSE, skip = 1)
# remove the last column.
df_test_body <- df_test_body[, 1:length(df_test_body)-1]
# set the names.
names(df_test_body) <- column_names
str(df_test_body); rm(df_test_body); rm(df_test_header)
```

There are more features that we want as factors than characters so we'll keep that default setting.  Contributor name should be a character, and zipcode should also be a character since it looks like some zipcodes are the full 9 digits and we're gonna have to do some string manipulation.  The receipt date should be a date object but we can also set that manually after we read in the data.

Now we can read in the entire contributions file.  We'll have to skip the header again but since we already have the column names from the test dataframe we can set them easily. We add a dummy name to the column names variable to account for the empty entry and then delete that column afterwards.

```{r load-contributions}
column_names <- c(column_names, "dummy")
df <- read.csv("campaign-contributions-ohio-2012.csv",
                     header = FALSE, col.names = column_names, skip = 1)
df$dummy <- NULL; head(df)
```

I'm curious to see how the `readr` package might have handled this, as it's supposed to be more intuitive with reading flat files.  The only drawback is that we would have to set the levels of the factors manually which could be pretty lengthy.  In any case, let's check it out.

```{r readr, echo=2}
library(readr)
df_readr <- read_csv("campaign-contributions-ohio-2012.csv", n_max = 100)
str(df_readr); rm(df_readr)
```

We got a warning about the column mismatch but `readr` handled the discrepancy.  We could have done this instead and set the factors one by one but `read.csv` allows us to set all characters as factors which was advantageous.  It took way more effort than `readr` would have, but it also allowed us to pinpoint the exact problem.

Back to loading the rest of the data. Let's load the geographic and demographic data and take a look at those.

```{r load-geo-demo, echo=FALSE, message=FALSE, warning=FALSE}
# geographic data.
data(zip.map); str(zip.map)
# demographic data.
data(df_zip_demographics); str(df_zip_demographics)
```

For both of these dataframes, the `region` variable (zipcode) is what we'll be using to relate to the contributions data.  For the demographic data, we can add the fields we want to the contributions dataframe.  However, we'll be making choropleth maps with the geographic data from different aggregate statistics from the contributions dataframe.  So we'll have to join these 2 on the fly depending upon what we want to show.

---

# Data Manipulation

Before adding the demographic data, let's get the contributions dataframe prepared. Let's get rid of the data we don't want and rename the columns.  There are quite a few features in the contribution data that don't really help our exploration like the ID number of the candidate or the file number of the contribution.  The only features of interest are `candidate`, `name` (of the contributor), `city`, `state`, `zipcode`, `employer`, `occupation`, `amount`, and `date`.

```{r trim-data}
df <- df[, 3:11]
# readable feature names.
names(df) <- c("candidate", "name", "city", "state", "zipcode",
                 "employer", "occupation", "amount", "date")
summary(df)
```

There's something interesting here that we can see by leaving the contributor names as factors.  There are a few contributors who made nearly 100 contributions.  We can also see which zipcodes had the most contributions.  This sort of supports my thoughts about splitting the data into 2 different sets, one for individual contributions and another for aggregate contributions per person.  For the aggregate dataset, I might want to use occupation or some grouping of that to approximate income since we don't have that feature.  If in the end our aim is to build a predictive model, then it might be better to try and predict total contribution number or amount per person rather than individual amounts.  I'll create an aggregate contributions dataset at the end of our data munging process when we have all the other features we want.  Then we can compare feature correlations between datasets to see if either one looks more promising for model building.

Let's coerce those features that we mentioned before to characters and make date into a date object.

```{r to-character}
to_character <- c("name", "zipcode", "date")

for(col in to_character) {
    df[, col] <- as.character(df[, col])
}

df$date <- as.Date(df$date, format = "%d-%b-%y"); sapply(df, class)
```

Now let's clean the zipcodes so that they all have just 5 digits, and so that we can relate them to the zipcodes in the geographic and demographic data.  We also have to make sure that they are in Ohio.

```{r clean-zipcodes}
df$zipcode <- substring(df$zipcode, 1, 5)
# if starts with '45' or '44' or '43' then in Ohio.
zip_legit <- as.character(seq(43000, 46000, by = 1))
# convert non-legit zipcodes to 'NA' character.
df$zipcode <- ifelse(df$zipcode %in% zip_legit, df$zipcode, 'NA')

summary(as.numeric(df$zipcode))
```

Looks like they are all within the correct range with the exception of the NAs.  This data won't be usable for the choropleth maps but it's still useful for other statistics so we'll keep it.

We do have negative amounts though, which happen to be refunds, so we'll have to exclude those observations.  Also, although the campaign contribution limit for an individual to a candidate was $2,500 in 2012, I want to include contributions made to parties so I won't be excluding observations made above that amount.

```{r refunds}
bad <- df$amount <= 0; sum(bad); df <- df[!bad, ]
```

There were `r sum(bad)` refunds excluded.

Let's engineer some features in order to make more use of the data that we have.  We'll get gender from name and party status from candidate.

```{r gender-party}
# clean names of 1, 2, and 3 letter abbreviations (MR., DR., A., MRS.)
df$name <- gsub("[A-Z]{1,3}\\.", "", df$name)
# only 1 whitespace
df$name <- gsub("( )+", " ", df$name)
# trim trailing and leading whitespace
df$name <- str_trim(df$name)

# make first name feature from full name.
df$first_name <- substring(str_extract(df$name, ',\\s[A-Z]+'), 3, )
# get dataframe of unique first names and gender.
gender_names_df <- gender(unique(df$first_name))
gender_names_df <- gender_names_df[, c("name", "gender")]

# join dataframe with gender names.
df <- merge(df, gender_names_df,
            by.x = 'first_name', by.y = 'name', all.x = TRUE)

# get rid of first name and gender names df, make gender a factor.
df$first_name <- NULL; rm(gender_names_df); df$gender <- as.factor(df$gender)
# NA gender count.
print("missing gender:"); sum(is.na(df$gender))

candidates <- unique(df$candidate)
democrat <- "Obama, Barack"; green <- "Stein, Jill"
republican <- candidates[!(candidates %in% c(democrat, green))]

df$party <- ifelse (df$candidate %in% republican, "republican",
                   ifelse (df$candidate == democrat, "democrat", "green"))
df$party <- as.factor(df$party)
```

There were quite a few people who's gender could not be deduced from the first name.  After looking into it, abbreviated first names and non-traditional english names were the biggest problems.

Now we can add demographic data to the dataset and scrape coordinates for major cities from the web.  The cities will help us to see the population centers better on the map.

```{r add-demographic-and-city}
demographics.ohio <- df_zip_demographics %>% filter(region %in% zip_legit)
df <- merge(df, demographics.ohio,
            by.x = 'zipcode', by.y = 'region', all.x = TRUE)
# shorten the names.
colnames(df)[12:19] <- c("population", "pcnt_wht", "pcnt_blk", "pcnt_asn",
                         "pcnt_hsp", "percap_incm", "med_rent", "med_age")
rm(df_zip_demographics)

# get city coordinates.
webpage_ohio_cities <-
  read_html("http://www.geonames.org/US/OH/largest-cities-in-ohio.html")
city_names <- webpage_ohio_cities %>%
  xml_find_all("//tr/td/a[contains(@href, 'geonames')]/text()") %>%
  as.character()
city_pop <- webpage_ohio_cities %>%
  xml_find_all("//tr/td[contains(@class, 'rightalign')]/text()") %>%
  as.character() %>%
  sub(",", "", .) %>%
  as.numeric()
city_coord <- webpage_ohio_cities %>%
  xml_find_all('//tr/td/a[contains(@href, "maps")]/text()') %>%
  as.character()
city_lat <- as.numeric(str_extract(city_coord, '^[0-9.]+'))
city_long <- as.numeric(str_extract(city_coord, '[-0-9.]+$'))

mapdata.ohio.cities <- data.frame(city_names, city_long, city_lat, city_pop)
```

Finally, we subset the map data for Ohio only since it includes the entire United States.

```{r trim-mapdata, echo=c(1)}
mapdata.ohio <- zip.map %>% filter(region %in% zip_legit) %>% arrange(order)
rm(zip.map)

## The correlations for the aggregate dataframe were only slightly better
## and there were lots of data inconsistencies to make use of occupation
## so this was not included in further analysis.

# Finally, we can create the aggregate contributions dataframe.
# I'll consider anybody with the same name, of the same gender,
# in the same zipcode, who made contributions to the same party, the same person
# (occupation and employer proved to be inconsistent for the same person across different contributions).
if(FALSE) {
df_agg <- df
# strip name of non-alphanumeric chars and whitespace.
df_agg$name <- df_agg$name %>% str_replace_all("[^[:alnum:]]", " ") %>%
    str_trim(side = "both")
# aggregate and set any inconsistencies in occupation to the string with lesser value (better hack?)
df_agg <- df_agg %>%
  group_by(name, gender, zipcode, party, percap_incm, med_age) %>%
  summarise(count = n(), total_amt = sum(amount),
            occupation = min(as.character(occupation)))
df_agg$occupation <- as.factor(df_agg$occupation)
df_agg <- as.data.frame(df_agg)
# summary and correlations
summary(df_agg); str(df_agg)
library(polycor); hetcor(df_agg[, c(2, 4:8)])
}

# SAVE OR LOAD DATA FROM '.Rdata' FILE FOR QUICK START.
#save(df, demographics.ohio, mapdata.ohio, mapdata.ohio.cities, file = "processed-data.Rdata")
#load("processed-data.Rdata")
```

As a side note, after exploring the aggregate contribution numbers and amounts per person, it doesn't look like the correlations were significantly stronger with aggregate amount than with the original data.  There were also a lot of inconsistencies with names and occupations.  Across donations some people used fake names, different variations of their name or different titles for the same occupation.  This made things a bit of a mess and I decided to leave a lengthy cleaning like that for another time.

---

# Univariate Plots Section

```{r global-options}
knitr::opts_chunk$set(echo=FALSE, warning=FALSE, message=FALSE)
```

Now that the data is in the right format let's start our univariate exploration.  Here are the names of all the features that we kept...

```{r univariate-plots}
names(df)
```

and the class of each feature as we saw before.  Zipcode was a character in the map dataframe so it was left like this in the contributions dataframe.

```{r}
str(df)
```

Here are the summary statistics for our features.

```{r}
summary(df)
```

The most popular candidate to receive contributions was Barack Obama and the most popular party was the democratic party.  The city with the most contributions was Cincinnati and retired people represented the occupation with the largest amount of contributions (although we're not actually going to use this).  The demographic of males made more contributions than females.  The median contribution was $`r median(df$amount)` and the average is $`r round(mean(df$amount))`.

For the following plots I'll use a purple color since the counts include both democrats and republicans.

```{r}
p1 <- ggplot(data = df, aes(x = amount)) +
  geom_density(fill = "mediumpurple4", color = "black") +
  scale_x_continuous(breaks = c(0, 1000, 2500, 5000, 10000))

# histogram
if (FALSE) {ggplot(data = df, aes(x = amount)) +
  geom_histogram(binwidth = 250, fill = "mediumpurple4", color = "black") +
  scale_x_continuous(breaks = c(0, 1000, 2500, 5000, 10000))}

p2 <- ggplot(data = df, aes(x = amount)) +
  geom_density(fill = "mediumpurple4", color = "black") +
  scale_x_log10(breaks = c(10, 100, 1000))

# histogram
if (FALSE) {ggplot(data = df, aes(x = amount)) +
  geom_histogram(fill = "mediumpurple4", color = "black") +
  scale_x_log10(breaks = c(10, 100, 1000))}

suppressMessages( grid.arrange(p1, p2, ncol = 1) )
```

We have long-tailed data for the amount of contributions. There are so many contributions made under $1,000 that it's hard to see any of the outliers.  A logarithmic transformation of the x-axis reveals something of a log-normal distribution for the amount although we can see that the data is more dense below the mean.  Let's check to see if the distribution is in fact log-normal.

```{r fig.height=4}
#standardize amount
amount_log_stand <- scale(log(df$amount))
# shapiro test takes a max of 5000 observations
set.seed(27)
amount_sample <- sample(amount_log_stand, 5000)
shapiro.test(amount_sample)
# qqplot
ggplot(amount_log_stand, aes(sample = amount_log_stand)) + stat_qq()
rm(amount_log_stand); rm(amount_sample)
```

A normality test of a random sample of the logarithm of amount rejects the assumption of normality, and the qqplot reaffirms this, so all we can really say is that the distribution of amount is long-tailed.

```{r}
p1 <- ggplot(data = df, aes(x = amount)) +
  geom_histogram(binwidth = 50, fill = "mediumpurple4", color = "black") +
  scale_x_continuous(breaks = c(250, 500, 1000, 1500, 2000, 2500)) +
  coord_cartesian(xlim = c(0, 3000))

p2 <- ggplot(data = df, aes(x = amount)) +
  geom_histogram(binwidth = 5, fill = "mediumpurple4", color = "black") +
  scale_x_continuous(breaks = seq(0, 250, 50)) +
  coord_cartesian(xlim = c(0, 300))

p3 <- ggplot(data = df, aes(x = amount)) +
  geom_histogram(binwidth = 1, fill = "mediumpurple4", color = "black") +
  scale_x_continuous(breaks = seq(0, 60, 5)) +
  coord_cartesian(xlim = c(0, 60))

grid.arrange(p1, p2, p3, ncol = 1)
```

There are a significant group of individuals (`r nrow(df[df$amount == 2500, ])`) that make the maxiumum contribution of $2,500.  Looking closer we can see that there appear to be several discrete values in increments of $50 that people generally contribute.  Under $60, we can see contributions spaced in intervals of $5.

```{r}
plot_bar_color <- function(feature) {
  ggplot(data = df, aes_string(x = feature)) +
    geom_bar(fill = "mediumpurple4", color = "black")
}

p1 <- plot_bar_color("as.factor(year(date))") + labs(x = "year") +
    scale_y_continuous(labels = comma)
p2 <- plot_bar_color("month(date, label=TRUE)") + labs(x = "month")
p3 <- plot_bar_color("as.factor(day(date))") + labs(x = "day")

grid.arrange(p1, p2, p3, ncol = 1)
```

An overwhelming majority of contributions (`r round(100* table(year(df$date))[2]/sum(table(year(df$date))), 1)`%) were made in 2012, and we can see a steady increase in contributions leading up to the election in November.  There seems to be a slight increase in the amount of contributions made toward the end of the month. There is also a peak at about halfway through the month. People might be making contributions immediately after receiving their paycheck or pension.

```{r fig.height=4}
plot_bar_color("gender")
```

Although a significant difference between the amount of male and female contributions, the proportion of the gap doesn't appear to be that large.

```{r}
p1 <- ggplot(data = df, aes(x = party, fill = party)) + geom_bar(color = "black") +
  scale_fill_manual(values = c("#377eb8", "#4daf4a", "#e41a1c"), guide = FALSE)

p2 <- ggplot(data = df,
             aes(x = reorder(candidate, candidate, function(x){length(x)}))) +
  geom_bar() + coord_flip() + theme(axis.title.y = element_blank())

p3 <- p2 + scale_y_log10(labels = comma)

grid.arrange(p1, p2, p3, layout_matrix = rbind(c(1,1),c(2,3)))
```

Most contributions are made to either Obama or Romney.  Using a log scale we can see the other candidates a little better.  Cumulatively, there are a significant amount of contributions made to other candidates and they appear to be mostly Republican.  The proportion of contributions to democrats vs. republicans seems to resemble the previous histrogram between Obama and Romney.  The amount of contributions to the green party is so small (`r sum(df$party == 'green')` contributions) that we might want to exclude for simplicity.
  
It's important to remember that the remaining demographic variables correspond to the contributor's zipcode and not to the contributor him/herself.

```{r}
plot_hist_color <- function(feature) {
  ggplot(data = df, aes_string(x = feature)) +
    geom_histogram(fill = "mediumpurple4", color = "black")
}

p0 <- plot_hist_color("population")
p1 <- plot_hist_color("pcnt_wht")
p2 <- plot_hist_color("pcnt_blk")
p3 <- plot_hist_color("pcnt_asn")
p4 <- plot_hist_color("pcnt_hsp")

suppressMessages( grid.arrange(p0, p1, p2, p3, p4,
                               layout_matrix = rbind(c(1,1), c(2,3), c(4,5))) )
```

Most contributors live in areas with a high percentage of white ethnicity and low percentages of black, asian, or hispanic ethnicities.

```{r}
p1 <- plot_hist_color("percap_incm")
p2 <- plot_hist_color("med_rent")
p3 <- plot_hist_color("med_age")

suppressMessages( grid.arrange(p1,p2,p3, ncol = 1) )
```

The distribution of per capita income in which contributors live appears poisson, with the bulk of contributors living in zipcodes with a range of per capita income of about $20,000 - $40,000.

We see a fairly normal distribution with median rent in the locations in which contributors live. Rent is very cheap (median of $`r median(df$med_rent, na.rm = TRUE)`) as compared to my home state of California but per capita income is also lower.

The median age in which contributors live also resembles a normal distrubtion with median `r median(df$med_age, na.rm = TRUE)`  I could not find exact statistics for the median age in Ohio in 2012, but in 2015 it appears to be 38.8.  We might be tempted to say that contributions come from areas where the population is slightly older which would make sense given the high number of contributions from people who listed their occupation as retired.  Whether or not the difference is significant would need some inferential analysis which is beyond the scope of this project.

```{r fig.height=10, fig.width=8}
total_cont_df <- df %>% group_by(zipcode) %>% summarise(count = n())
# can't create count buckets and use that variable to fill the polygon.
# it has to be created within the geom.
quants <- quantile(total_cont_df$count,
                   probs = c(0, .15, .3, .45, .55, .70, .85, 1))

ggplot() +
  geom_map(data = mapdata.ohio, map = mapdata.ohio,
                    aes(map_id = region, x = long, y = lat, group = group),
                    fill = "white", color = "lightgray") +
  geom_map(data = total_cont_df, map = mapdata.ohio,
           aes(map_id = zipcode,
               fill = cut(count, breaks = quants, include.lowest = TRUE)),
           color = "lightgray", alpha = 0.8) +
  scale_fill_brewer(name = 'Total Contributions', palette  = 'Purples') +
  geom_point(data = mapdata.ohio.cities,
             aes(x = city_long, y = city_lat, group = NULL), # size = city_pop
             size = 2, color = 'black') +
  geom_text(data = mapdata.ohio.cities,
            aes(x = city_long, y = city_lat, group = NULL, label = city_names),
            size = 4, color = 'black', hjust = 1, vjust = -2, fontface = 2) +
    theme_map() + theme(legend.position = "bottom") +
    coord_map(projection = "mercator")

# this method works as well but less intuitive with longitude and latitude.
if (FALSE){
  ggplot(total_cont_df, aes(map_id = zipcode,
                            fill = cut(count,
                                       breaks = quants,
                                       include.lowest = TRUE))) +
    geom_map(map = mapdata.ohio) +
    expand_limits(x = mapdata.ohio$long, y = mapdata.ohio$lat) +
    scale_fill_brewer(palette  = 'Purples', guide = FALSE)
}

# this method too slow with map-data concatenation and geom_polygon.
if (FALSE) {
ptm <- proc.time()

mapdata.ohio.cont <- merge(mapdata.ohio, total_cont_df,
                           by.x = 'region', by.y = 'zipcode',
                           all.x = TRUE) %>% arrange(order)

ggplot(data = mapdata.ohio.cont, aes(x = long, y = lat, group = group)) +
  geom_polygon(aes(fill = cut(count, breaks = quants, include.lowest = TRUE)),
               alpha = 1) +
  geom_path(colour = 'lightgray') +
  scale_fill_brewer(name = 'Total Contributions', palette  = 'Purples') +
  coord_map(projection = "mercator") +
  geom_point(data = mapdata.ohio.cities,
             aes(x = city_long, y = city_lat, group = NULL),
             size = 2, color = 'gold') +
  geom_text(data = mapdata.ohio.cities,
            aes(x = city_long, y = city_lat, group = NULL, label = city_names),
            size = 4, color = 'gold', hjust = 1, vjust = -2, fontface = 2) +
  theme_map() + theme(legend.position = "bottom")

proc.time() - ptm
}
```

A choropleth map of total contributions by zipcode shows that most contributions generally come from areas nearer to cities.  There are also quite a few zipcodes without any contributions (seen with white color).

---

# Univariate Analysis

### What is the structure of your dataset?

There are `r nrow(df)` instances of campaign contribution in the dataset with `r ncol(df)` features.  From the original data set 11 features were kept or derived:  

* candidate
* name (contributor)
* city
* state
* zipcode
* employer
* occupation
* amount
* date
* gender
* party

and a total of 8 demographic features were linked by zipcode from another data set:  

* total_population
* percent_white
* percent_black
* percent_asian
* percent_hispanic
* per_capita_income
* median_rent
* median_age

From the original data set, all but name, amount, and date are factors. None of the factors are ordered. Name is a character, amount is numeric, and date is a date object. The 8 demographic features are all numeric.  

Other observations:  

* The largest group of contributors by occupation are retirees
* About 60% of contributions are made by democrats
* The median contribution amount is $50 and the maximum is $2,500
* Barack Obama received 60% of contributions
* Women accounted for 45% of contributors
* The number of monthly contributions show an exponential increase as the election approaches

### What is/are the main feature(s) of interest in your dataset?

The main features of interest in the data set are amount, gender, party, per capita income, and median age. I would like to see if these factors are correlated with contribution amount. Occupation could be of interest however there are too many levels `r length(levels(df$occupation))`.

### What other features in the dataset do you think will help support your investigation into your feature(s) of interest?

I believe that the percent ethnicities, total population, and median rent may be correlated with contribution amount.

### Did you create any new variables from existing variables in the dataset?

I created two new variables, one for the gender of the contributor based upon the first name, and another for the party of the contributor based upon the candidate that received the contribution. I was unable to programatically determine gender by first name for about `r sum(is.na(df$gender))` instances (approx. `r 100* round(sum(is.na(df$gender)) / nrow(df), 2)`% of the data).

### Of the features you investigated, were there any unusual distributions? Did you perform any operations on the data to tidy, adjust, or change the form of the data? If so, why did you do this?

Amount was long-tailed so I log-transformed this distribution but it proved to be non-normal.  To remove outliers or non-pertinent data, I excluded refunds but not contributions over the allowable limit for an individual ($2,500).  The amounts over this limit could be made to the party or come from Political Action Committees (PAC) which have a larger limit.  Other than this, the contribution data already came in a tidy format.

---

# Bivariate Plots Section

Before I plot any bivariate relationships, I want to see a correlation matrix of my variables of interest.  This will help to focus the rest of my exploration.

```{r bivariate_plots}
# add time as numeric date variable
df$time <- as.numeric(as.POSIXct(df$date, format="%Y-%m-%d %H:%M:%S"))
keep <- !is.na(df$gender) & df$party != "green"
correlations <- hetcor(df[keep, c(8, 10:20)], std.err = FALSE)
correlations
```

Party, percapita income of the contributor's zipcode, gender, and time are the only variables with a correlation coefficient above 0.10 with amount.  Of these, gender and party had the strongest correlation at 0.36 which is somewhat significant.  Time has a negative correlation with amount indicating that despite the increase in contributions leading up to the election, amount of a contribution seems to wane as the election approaches.  I've never been to Ohio but because of the strong negative correlation between percentage of white and black ethnicity for a contributor's zipcode, I would guess that it is somewhat segregated.

```{r pairs_plot, eval=FALSE, cache=TRUE, cache.path='cache/', fig.path='figure/'}
pairs_df <- df[, c("amount", "party", "percap_incm", "gender", "time")] %>%
  filter(!(is.na(gender)), party != "green")

pairs_plt = ggpairs(pairs_df, color = "gender",
                      #params=list(size=2))
                    
print(pairs_plt, left = 0.75, bottom = 0.75)
```

```{r}
p1 <- ggplot(data = df, aes(x = month(date, label=TRUE),
                            fill = as.factor(year(df$date)))) +
  geom_bar(position = "dodge", color = "black") +
  scale_fill_manual(values = c("hotpink2", "hotpink4")) +
  theme(legend.position = "bottom", legend.title=element_blank(),
        axis.title.x = element_blank())

p2 <- ggplot(aes(y = amount, x = as.factor(year(date)),
                 fill = as.factor(year(df$date))), data = df) +
  geom_boxplot(outlier.color = NA) +
  stat_summary(fun.y = mean, geom = "point", size = 3) +
  coord_cartesian(ylim = c(0, 400)) +
  scale_fill_manual(values = c("hotpink2", "hotpink4"), guide = FALSE) +
  theme(axis.title.x = element_blank())

grid.arrange(p1, p2, ncol = 1)
tapply(df$amount, as.factor(year(df$date)), summary)
wilcox.test(amount ~ year(date), data = df)
```

Contributions really ramp up in the summer before the election. The average contribution amount is significantly higher in 2011 than in 2012 although the biggest outlier is in 2012.  Because amount is not normally distributed, I use a non-parametric test to see if the populations are significantly different over both years which they are.

```{r}
good <- !is.na(df$gender) & df$party != "green"

p1 <- ggplot(data = df[good, ], aes(x = party, fill = gender)) +
  geom_bar(position = "dodge", color = "black") +
  scale_fill_brewer(palette = 'Set2', direction = -1)

p2 <- ggplot(data = df[good, ], aes(x = gender, y = amount, fill = gender)) +
  geom_boxplot(outlier.color = NA) +
  stat_summary(fun.y = mean, geom = "point", size = 3) +
  scale_fill_brewer(palette = 'Set2', direction = -1, guide = FALSE) +
  coord_cartesian(ylim = c(0, 400))

grid.arrange(p1, p2, ncol = 1)
tapply(df$amount, df$gender, summary)
wilcox.test(amount ~ gender, data = df[good, ])
```

Contributions to the Democratic party came from a slight female majority whereas contributions to the Republican party came from an overwhelming male majority.  The mean contribution amount as well as the IQ range is larger for males than females and they are significantly different.

```{r fig.height=4}
no_green <- df$party != "green"

ggplot(data = df[no_green, ],
       aes(x = party, y = amount, fill = party)) +
  geom_boxplot(outlier.color = NA) +
  stat_summary(fun.y = mean, geom = "point", size = 3) +
  scale_fill_brewer(palette = 'Set1', direction = -1, guide = FALSE) +
  coord_cartesian(ylim = c(0, 400))

tapply(df$amount[no_green], df$party[no_green], summary)
wilcox.test(amount ~ party, data = df[no_green, ])
```

This definitely resembles the previous plot.  Republicans also have a higher mean contribution amount and IQ range than democrats and the groups are significantly different.

```{r fig.height=4}
ggplot(data = df, aes(x = percap_incm, y = amount)) +
  geom_jitter(alpha = 0.02) +
  geom_smooth(method = 'lm', color = "gold") +
  geom_smooth(color = "gold") +
  coord_cartesian(ylim = c(0, 1000))

cor.test(df$percap_incm, df$amount)
```

This is a weak correlation as seen by the points in the plot and the trend is probably due to the higher per capita income demographic around 60K.

```{r fig.height=4}
ggplot(aes(y = amount, x = date), data = df) +
  geom_jitter(alpha = 0.02) +
  geom_smooth(method = 'lm', color = "hotpink3") +
  geom_smooth(color = "hotpink3") +
  coord_cartesian(ylim = c(0, 1000))

cor.test(df$time, df$amount)
```

It's interesting to see that there is a second peak in this plot.  Almost like a final rally in contribution amount just before the election.

Based off the results from this bivariate exploration (and perhaps prior suspicion) I want to see if the correlation of amount across gender, party, and per capita income of the contributor's zipcode still hold if exteme outliers are removed.  I suspect that there are large donations coming from republican males residing in high per capita income areas which may skewing the correlations.

```{r}
# 98th percentile is max contribution limit of $2500 and above
outliers <- df$amount >= quantile(df$amount , 0.98)
keep <- !is.na(df$gender) & df$party != "green"
df_test <- df[!outliers & keep, c("amount", "gender", "party", "percap_incm")]
hetcor(df_test, std.err = FALSE)
summary(df[outliers, c("amount", "gender", "party", "percap_incm")])
```

Removing the 98th percentile of outliers (which corresponds to the maximum contribution limit of $2500 and above), we can see that the correlations for party and per capita income are slightly reduced while the correlation with gender slightly increased.  This implies that most of the outliers were republicans from higher per capita income areas but that females also played a significant part in these contributions.

Next I want to look at total contribution amounts by party on the map.  My guess is that rural areas will show more Republican contributions.  The colors for each map correspond to percentile buckets with cuts at 15%, 30%, 45%, 55%, 70%, %85, and 100%.

```{r fig.height=10, fig.width=8}
total_amt_dem_df <- df[(df$party == "democrat"), ] %>% group_by(zipcode) %>%
    summarise(total_amt = sum(amount))

quants <- quantile(total_amt_dem_df$total_amt,
                   probs = c(0, .15, .3, .45, .55, .70, .85, 1))

ggplot() +
  geom_map(data = mapdata.ohio, map = mapdata.ohio,
                    aes(map_id = region, x = long, y = lat, group = group),
                    fill = "white", color = "lightgray") +
  geom_map(data = total_amt_dem_df, map = mapdata.ohio,
           aes(map_id = zipcode,
               fill = cut(total_amt, breaks = quants, include.lowest = TRUE)),
           color = "lightgray", alpha = 0.8) +
  scale_fill_brewer(name = 'Total Contributions by Democrats',
                    palette  = 'Blues') +
  geom_point(data = mapdata.ohio.cities,
             aes(x = city_long, y = city_lat, group = NULL),
             size = 2, color = 'black') +
  geom_text(data = mapdata.ohio.cities,
            aes(x = city_long, y = city_lat, group = NULL, label = city_names),
            size = 4, color = 'black', hjust = 1, vjust = -2, fontface = 2) +
    theme_map() + theme(legend.position = "bottom") +
    coord_map(projection = "mercator")
```


```{r fig.height=10, fig.width=8}
total_amt_rep_df <- df[(df$party == "republican"), ] %>% group_by(zipcode) %>%
    summarise(total_amt = sum(amount))

quants <- quantile(total_amt_rep_df$total_amt,
                   probs = c(0, .15, .3, .45, .55, .70, .85, 1))

ggplot() +
  geom_map(data = mapdata.ohio, map = mapdata.ohio,
                    aes(map_id = region, x = long, y = lat, group = group),
                    fill = "white", color = "lightgray") +
  geom_map(data = total_amt_rep_df, map = mapdata.ohio,
           aes(map_id = zipcode,
               fill = cut(total_amt, breaks = quants, include.lowest = TRUE)),
           color = "lightgray", alpha = 0.8) +
  scale_fill_brewer(name = 'Total Contributions by Republicans',
                    palette  = 'Reds') +
  geom_point(data = mapdata.ohio.cities,
             aes(x = city_long, y = city_lat, group = NULL),
             size = 2, color = 'black') +
  geom_text(data = mapdata.ohio.cities,
            aes(x = city_long, y = city_lat, group = NULL, label = city_names),
            size = 4, color = 'black', hjust = 1, vjust = -2, fontface = 2) +
    theme_map() + theme(legend.position = "bottom") +
    coord_map(projection = "mercator")
```

Both of the maps seem to have the heaviest concentrations of total amounts coming from city areas but it does look like there are more dark colors away from cities for the republican party.

---

# Bivariate Analysis

### Talk about some of the relationships you observed in this part of the investigation. How did the feature(s) of interest vary with other features in the dataset?

There were no strong relationships discovered between amount and any of the other features. The 3 features with correlation values above 0.10 with amount were party (0.36), per capita income of the contributor's zipcode (0.16), gender (0.12), and time (-0.11).

### Did you observe any interesting relationships between the other features (not the main feature(s) of interest)?

The strongest relationship among all the variables was that between percent white and percent black of a contributors location. These are negatively correlated at 97%.

### What was the strongest relationship you found?

The inverse relationship between white and black percentage of a contributor's zipcode.  Among the variables of interest the strongest correlation was between party and amount which is not entirely surprising.

---

# Multivariate Plots Section

Now I'll take a look at the relationships between amount and a combination of the highly correlated features from the bivariate exploration.  There are a lot of contributions in the dataset and with scatterplots it's difficult to see the relationships especially since the correlations are weak, so I'll be using smoothing lines instead.

```{r multivariate_plots}
p1 <- ggplot(data = df[!is.na(df$gender), ],
       aes(x = percap_incm, y = amount, color = gender)) +
  scale_color_brewer(palette = 'Set2', direction = -1) +
  geom_smooth() + geom_smooth(method = 'lm')

p2 <- ggplot(data = df[df$party != "green", ],
       aes(x = percap_incm, y = amount, color = party)) +
  scale_color_brewer(palette = "Set1", direction = -1) +
  geom_smooth() + geom_smooth(method = 'lm')

grid.arrange(p1, p2, ncol = 1)
```

The first plot of amount by per capita income faceted by gender doesn't really give us any new information.  Both lines for gender have a similar slope and mirror each other.  The vertical translation between the lines only highlights what we saw before in the bivariate section with respect to the differences in mean contribution amount across gender.  The second plot, however, seems to show that as the per capita income of a contributor's zipcode increases, republicans make donations in larger amounts as compared to democrats.  The high starting point for the LOESS smoothing line in both plots looks like it's due to some outliers who donated large amounts but who reportedly reside in areas with low per capita income.

```{r}
p1 <- ggplot(data = df[!is.na(df$gender), ],
       aes(x = date, y = amount, color = gender)) +
  scale_color_brewer(palette = 'Set2', direction = -1) +
  geom_smooth() + geom_smooth(method = 'lm')

p2 <- ggplot(data = df[df$party != "green", ],
       aes(x = date, y = amount, color = party)) +
  scale_color_brewer(palette = "Set1", direction = -1) +
  geom_smooth() + geom_smooth(method = 'lm')

grid.arrange(p1, p2, ncol = 1)
```

As in the previous plot grid, time doesn't seem to be a factor across gender for contribution amount.  Converseley, there is a difference across party, and it looks as if contribution amounts for republicans have 2 peaks.  The first peak is somewhat shared for both parties and corresponds to what we saw before with larger contribution amounts in 2011 vs 2012.  The second peak is pretty exclusive to the republican party though, and it looks like republicans donate in larger amounts right before the election as compared to democrats.

```{r fig.height=5, fig.width=7}
df_agg <- df[good, ] %>% group_by(gender, party) %>%
    summarise(avg_amt = mean(amount, rm.na = TRUE))

ggplot(df_agg, aes(x = gender, y = party)) +
    geom_raster(aes(fill = log(avg_amt))) +
    scale_fill_distiller(palette = "Greens", direction = 1) + theme_dark()

spread(df_agg, gender, avg_amt) %>% arrange(desc(male))
```

The heat map and table show the two highly correlated categorical variables with average contribution amount.  Seeing the numbers does put it in perspective.

I want to look at the average contribution by zipcode to see if there is any difference between urban and suburban/rural areas.

```{r fig.height=10, fig.width=8}
df_avg_amt <- df %>% group_by(zipcode) %>% # add party to group for ggvis
  summarise(count = n(), total_amt = sum(amount)) %>%
  mutate(avg_amt = total_amt / count)

quants <- quantile(df_avg_amt$avg_amt,
                   probs = c(0, .15, .3, .45, .55, .70, .85, 1))

ggplot() +
  geom_map(data = mapdata.ohio, map = mapdata.ohio,
                    aes(map_id = region, x = long, y = lat, group = group),
                    fill = "white", color = "lightgray") +
  geom_map(data = df_avg_amt, map = mapdata.ohio,
           aes(map_id = zipcode,
               fill = cut(avg_amt, breaks = quants, include.lowest = TRUE)),
           color = "lightgray", alpha = 0.8) +
  scale_fill_brewer(name = 'Average Contribution',
                    palette  = 'Greens') +
  geom_point(data = mapdata.ohio.cities,
             aes(x = city_long, y = city_lat, group = NULL),
             size = 2, color = 'black') +
  geom_text(data = mapdata.ohio.cities,
            aes(x = city_long, y = city_lat, group = NULL, label = city_names),
            size = 4, color = 'black', hjust = 1, vjust = -2, fontface = 2) +
    theme_map() + theme(legend.position = "bottom") +
    coord_map(projection = "mercator")
```

It looks like the areas with the highest average contribution amounts aren't necessarily closest to cities.  If 1 on 1 interaction between candidates and people is what gets donations for a campaign, then time would be best spent in these outer city areas.

```{r experimental_plots, eval=FALSE}
total_cont_df <- df %>% group_by(zipcode) %>% summarise(count = n())

quants <- quantile(total_cont_df$count,
                   probs = c(0, .15, .3, .45, .55, .70, .85, 1))

mapdata.ohio.cont <- merge(mapdata.ohio, total_cont_df,
                           by.x = 'region', by.y = 'zipcode',
                           all.x = TRUE) %>% arrange(order)

# ggvis
library(ggvis)
mapdata.ohio.cont %>%
  ggvis(~long, ~lat) %>% group_by(group) %>%
  layer_paths(fill =~cut(count, breaks = quants, include.lowest = TRUE)) %>%
  scale_ordinal("fill",
                range=c("#fee5d9", "#fcbba1", "#fc9272", "#fb6a4a", "#ef3b2c",
                        "#cb181d", "#99000d"))

# leaflet
library(leaflet)
leaflet_map <- mapdata.ohio.cont[1:400, ]
#split(leaflet_map, leaflet_map$group)
for(row in leaflet_map[1:20, ]) {
  print(row["group"])
}
library(rgdal) #maptools?
leaflet_map[149, ] <- rep(NA, ncol(leaflet_map))
leaflet() %>% addTiles() %>% addPolygons(data = leaflet_map,
                                         lng = ~long, lat = ~lat,
                                         color = ~pal(count))

# ggmaps
library(ggmap)
qmap('ohio', zoom = 7, maptype = 'roadmap')
```

I want to build a linear model of my most highly correlated features to try and predict amount.  I'll be predicting the log of amount since we saw that the distribution was closest to that.  I'll also add features one by one to my model in order of highest correlation to see if there are improvements in performance.

```{r biuld_linear_model}
df$time <- as.numeric(as.POSIXct(df$date, format="%Y-%m-%d %H:%M:%S"))
keep <- df$party != "green" & !is.na(df$gender)
model_df <- df[keep, c("amount", "party", "percap_incm", "gender", "time")] %>%
  na.omit()

m1 <- lm(log(amount) ~ party,
         data = model_df)
m2 <- update(m1, ~ . + percap_incm)
m3 <- update(m2, ~ . + gender)
m4 <- update(m3, ~ . + time)
mtable(m1, m2, m3, m4)
```

All features remain significant for all models although the explained variance (R-sqaured) seems to be the same for each model (to one decimal).  The coefficients look as if they are near zero for per capita income and time (could be due to rounding).  I'm somewhat surprised here since the correlation coefficient for per capita income was higher than gender.  We are prediciting the logarithm of amount so even a small value could be significant in accounting for variance.  I want to zoom in a little more and see detail for the difference between each model.

```{r}
anova(m1, m2)
```

The F-test shows a very small p-value indicating significance of per capita income. The sum of squared error also decreases so per capita income definitely improves the model.

```{r}
anova(m2, m3)
```

Same here with gender, we see significance with both metrics although much less explained error than before.

```{r}
anova(m3, m4)
```

Time is also significant.

I'll plot the residuals to see if a linear model was the right choice for predicting the logarithm of amount.

```{r}
autoplot(m4, which = 1:2, ncol = 2, label.size = 2)
```

We can see here that the residuals are close to normal around the middle range of values but deviate at the extremes.  It looks like there is a slope towards negative error as the value of the logarithm of amount increases.  As we saw with the distribution of amount, it wasn't perfectly log-normal so I'm not entirely suprised.  Let's take a look at the final statistics for the model with all features included (party, per capita income, gender, and time).

```{r}
summary(m4)

#thisDonation <- head(model_df)[3,c(9,2,3)]
#thisDonation <- head(model_df)[1,c(9,2,3)]
#thisDonation <- head(model_df)[2,c(9,2,3)]
#modelEstimate = predict(m3, newdata = thisDonation,
#                        interval="prediction", level = .95)
# Need to exponentiate the modelEstimate.
#exp(modelEstimate)
```

The coefficients for per capita income and time are in fact pretty small but not zero.  The R-squared value is precisely 0.1998 and p-value indicates significance.  All these statistics show that each feature added was significant and helped to improve the fit of the model.  Even so, the correlation coefficients for per capita income and time were very small compared to party and gender.  Again, I'm a bit surprised since per capita income had a stronger correlation to amount than gender.  In the end, the linear model only accounted for about 20% of the variation in donation amount which means that our features are still poor predictors for contribution amount.

---

# Multivariate Analysis

### Talk about some of the relationships you observed in this part of the investigation. Were there features that strengthened each other in terms of looking at your feature(s) of interest?

Gender strengthened the difference in amount seen across per capita income, and party did the same for time.  It also seems that urban areas are not the most important areas in terms of average contribution amount.

### Were there any interesting or surprising interactions between features?

As per capita income of a contributor's area increases, the contribution amount increases more so for republicans than democrats.  This was interesting to see because the correlation seems to imply that republicans are more generous with their donations as their financial demographic improves.  Another interesting interaction for contribution amount was across time and party.  Both parties seems to have higher contribution amounts earlier on but leading up to the election, republicans sort of rally behind their candidate for one last push.  Whether or not this is effective in catapulting a candidate to nomination is a whole other question but it does remind me of increasingly invasive party advertisements that you see before an election.

### OPTIONAL: Did you create any models with your dataset? Discuss the strengths and limitations of your model.

I created a linear model to predict the logarithm of amount from the highest correlated features.  I was surprised to see that the coefficients for per capita income and time were near zero while gender, despite having a weaker correlation than per capita income, had a larger coefficient.  Party was the most important variable in explaining the variance in contribution amount. In the end the model only accounted for about 20% of the variation in amount so the features were poor.

------

# Final Plots and Summary

### Plot One

```{r plot_one}
# plot of distribution over months and amount by year
if (FALSE) {
p1 <- ggplot(data = df, aes(x = month(date, label=TRUE),
                            fill = as.factor(year(df$date)))) +
    geom_bar(position = "dodge", color = "black") +
    scale_fill_manual(values = c("hotpink2", "hotpink4"), guide = FALSE) +
    ggtitle('Distribution by Time') +
    xlab('Month') + 
    ylab('Number of Contributions')

p2 <- ggplot(aes(y = amount, x = as.factor(year(date)),
                 fill = as.factor(year(df$date))), data = df) +
    geom_boxplot(outlier.color = NA) +
    stat_summary(fun.y = mean, geom = "point", size = 3, show.legend = FALSE) +
    coord_cartesian(ylim = c(0, 400)) +
    scale_fill_manual(values = c("hotpink2", "hotpink4"), name = "Year") +
    ggtitle('Amount by Year') +
    xlab('Year') + 
    ylab('Amount of Contribution (USD)')

# Contributions increase steadily from 2011 until the summer of 2012 before the election.  During the summer and into the fall, contributions increase exponentially.  Despite the increase in contributions leading up to the election, contribution amounts are on average lower in 2012 than in 2011.
}

good <- !is.na(df$gender) & df$party != "green"

p1 <- ggplot(data = df[good, ], aes(x = party, fill = gender)) +
  geom_bar(position = "dodge", color = "black") +
  scale_fill_brewer(palette = 'Set2', direction = -1) +
  ggtitle('Distribution by Party and Gender') +
  xlab('Party') + 
  ylab('Count')

p2 <- ggplot(data = df[good, ], aes(x = gender, y = amount, fill = gender)) +
  geom_boxplot(outlier.color = NA) +
  stat_summary(fun.y = mean, geom = "point", size = 3, show.legend = FALSE) +
  scale_fill_brewer(palette = 'Set2', direction = -1) +
  coord_cartesian(ylim = c(0, 400)) +
  ggtitle('Amount by Gender') +
  xlab('Gender') + 
  ylab('Amount (USD)')

grid.arrange(p1, p2, ncol = 2)
```

### Description One

Most contributions were made to the democratic party, and those came from a slight majority of females while most republican contributions were made by an overwhelming majority from males.  The average contribution amount is higher for males than for females.

### Plot Two

```{r plot_two}
good <- !is.na(df$gender) & df$party != "green"

p1 <- ggplot(data = df[df$party != "green", ],
       aes(x = percap_incm, y = amount, color = party)) +
  scale_color_brewer(palette = 'Set1', direction = -1) +
  geom_smooth() +
  ggtitle('Amount by Income and Party') +
  xlab('Per Capita Income (USD)') + 
  ylab('Amount (USD)')

p2 <- ggplot(data = df[df$party != "green", ],
       aes(x = date, y = amount, color = party)) +
  scale_color_brewer(palette = 'Set1', direction = -1) +
  geom_smooth() +
  ggtitle('Amount by Date and Party') +
  xlab('Date') + 
  ylab('Amount (USD)')

grid.arrange(p1, p2, nrow = 2)
```

### Description Two

Republicans had on average higher contribution amounts than did democrats.  As the per capita income of a contributor's area increases, the amount donated increases at a higher rate for republicans than democrats.  Also, leading up to the election, republican donation amounts show a rally just before the election whereas democrats tend to donate in steadily decreasing amounts.

### Plot Three

```{r plot_three, fig.height=11, fig.width=8}
df_avg_amt <- df %>% group_by(zipcode) %>% # add party to group for ggvis
  summarise(count = n(), total_amt = sum(amount)) %>%
  mutate(avg_amt = total_amt / count)

quants <- quantile(df_avg_amt$avg_amt,
                   probs = c(0, .15, .3, .45, .55, .70, .85, 1))

# quantile ranges to character strings
quant_name_low <- as.character(unname(floor(quants)))
quant_name_high <- as.character(unname(floor(quants + 1)))
quant_name <- paste(quant_name_high[-length(quants)], "-", quant_name_low[-1])
# reset first range
quant_name[1] <- paste(quant_name_low[1], "-", quant_name_low[2])

ggplot() +
    geom_map(data = mapdata.ohio, map = mapdata.ohio,
             aes(map_id = region, x = long, y = lat, group = group),
             fill = "white", color = "lightgray") +
    geom_map(data = df_avg_amt, map = mapdata.ohio,
             aes(map_id = zipcode,
                 fill = cut(avg_amt, breaks = quants, include.lowest = TRUE)),
             color = "lightgray", alpha = 0.8) +
    scale_fill_brewer(palette  = 'Greens', labels = quant_name) +
    geom_point(data = mapdata.ohio.cities,
               aes(x = city_long, y = city_lat, group = NULL),
               size = 2, color = 'black') +
    geom_text(data = mapdata.ohio.cities,
              aes(x = city_long, y = city_lat, group = NULL, label = city_names),
              size = 4, color = 'black', hjust = 1, vjust = -2, fontface = 2) +
    theme_map() + theme(legend.position = "bottom",
                        plot.title = element_text(size = 15)) +
    coord_map(projection = "mercator") +
    ggtitle('Choropleth of Average Contribution Amount') +
    guides(fill = guide_legend(title = "Amount (USD)"))
```

### Description Three  

This final plot shows that, despite total contribution amount being highly correlated with city center, average contribution amount is highest in some rural areas. This may shed light on why presidential candidates spend a significant amount of time campaigning in suburbs and seemingly rural areas.

------

# Reflection

In this investigation of campaign contributions, I chose to focus on identifying the most significant features that could be used to predict contribution amount. The most significant features proved to be party, gender, per capita income of the area in which the contributor lives (an approximation of income), and time. Given these correlated features, the highest contribution amount would probably be made in the year before the election by a male republican living in a suburban or rural area of high per capita income (I guess no surprises here).

Despite these findings, the linear model used to explain contribution amount was only able to account for about 20% of the variation.  It would have been great to have actual income, age, and ethnicity of the contributor him/herself.  The next best thing to approximate income would have been to use the occupations feature although as I found it would take some time to clean it.

With regard to the choropleth maps, it seemed apparent that total contributions and total contribution amount were correlated with city centers.  Average contribution per zipcode didn't seem to follow this though, and those highest amounts appeared to be either surrounding cities (with a buffer) or in some other rural areas.  Data about the population density of each zipcode could be useful in creating another feature for rural, suburban, or urban areas (population count for each zipcode was available but area wasn't).

There were two major shortcomings during the analysis both due to really dirty string data.  First was the inability to programatically determine the gender by first name for about 3% of the data.  The second was the mess that was the occupations feature which could have been engineered into another good predictor.  Also, I wanted to create an aggregate for each person but as mentioned the names were too inconsistent.

One last idea for future exploration would have been to get location data for more cities.  The average longitude and latitude of each zipcode could have been calculated as well as the distance to the nearest big city.  This would be another way (like the rural/suburban/urban feature but numerical) to see if distance played any roll in contribution amount.
